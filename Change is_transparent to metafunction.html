<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style type="text/css">
pre {margin-left:20pt; }
pre > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
pre > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table.header { border: 0px; border-spacing: 0;
  margin-left: 0px; font-style: normal; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none; 
  padding-right: 0.4em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none;
  padding-right: 0.4em; border: none; }
</style>

<title>Change is_transparent to metafunction</title>
</head>

<body>

<table class="header"><tbody>
  <tr>
    <th>Document number:&nbsp;&nbsp;<th> <td></td>
  </tr>
  <tr>
    <th>Date:&nbsp;&nbsp;<th> <td></td>
  </tr>
  <tr>
    <th>Project:&nbsp;&nbsp;<th> <td>Programming Language C++, Library Evolution Working Group</td>
  </tr>
  <tr>
    <th>Reply-to:&nbsp;&nbsp;<th> <td><address>Tomasz Kamiński &lt;tomaszkam at gmail dot com&gt;</address></td>
  </tr>
</tbody></table>

<h1><a name="title">Change is_transparent to metafunction</a></h1>

<h2><a name="intro">Introduction</a></h2>

<p>This proposal discusses an alternative design for enabling a heterogeneous lookup function in the associative containers in the form of a metafunction.</p>

<p>This paper is result of the LWG recommendation provided in the resolution of the <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4383.html#2430">LWG issue #2430</a>.</p>

<!--h2><a name="toc">Table of contents</a></h2-->

<h2><a name="motivation">Motivation and Scope</a></h2>

<p>In the scope of this paper we propose a new metafunction <code>permits_heterogenous_lookup</code>.
This metafunction is designed to be used to enable the heterogeneous lookup in associative container, instead
of the current standard method relying on presence of <code>is_transparent</code> nested type in the comparator
type ($23.2.4 [associative.reqmts]).</p>

<h3><a name="motivation.backward-compatibility">Presreving backward compatibility</a></h3>

<p>The addition of the heterogeneous lookup to the container may silently change the behavior of the existing code,
and to avoid such situations it was designed as an opt-in feature. However, the mechanism created for the purpose
is not always working correctly - existing programs may define <code>is_transparent</code> nested type in their
comparator type, and as a consequence the meaning of such programs will be changed.</p>

<p>The introduction of the type trait allows the users to resolve the backward compatibility problem described above
via providing an explicit specialization of the trait that derives from the <code>std::false_type</code>. 
It is worth noting that this is only a viable resolution for the situation when the programmer does not have the
controll over the comparator's code.</p>

</p>Futhermore, it is possible to avoid false positives via providing the default definition
of <code>permits_heterogenous_lookup</code> that has BaseCharacteristic of <code>std::false_type</code>.
However, such design will no longer support user-defined comparators that intentionally enable new lookup function
by declaring nested type <code>is_transparent</code>.</p>

<p>The resolution of this problem is discussed in <a href="design.backward-compatibility">Backward compatibility</a>
subsection of the proposal.</p>

<h3><a name="motivation.third-party">Support for third party comparators</a></h3>

<p>In the current design enabling heterogeneous lookup requires a modification of the comparator class to 
declare a nested type. As a consequence of this intrusiveness, the users cannot enable this functionality
for the third-party comparison types that are outside of their control, even if they know that such operation
is supported.</p>

<p>In contrast, the use of a type trait allows the new lookup mechanism to be enabled in the program without any
modification to the third party libraries.</p>


<h3><a name="motivation.wrappers">Creating transparent call wrappers</a></h3>

<p>The introduction of the type trait would also simplify the definition of call wrapper types that would like 
to 'inherit' the heterogenous comparison trait from the wrapped callable.</p>

<p>Suppose we are creating <code>call_wrapper&lt;F&gt;</code>. In the case of the proposed <code>permits_heterogenous_lookup</code>
trait, the implementation is pretty straight-forward:</p>
<pre>namespace std
{
  template&lt;typename F&gt;
  struct permits_heterogenous_lookup&lt;call_wrapper&lt;F&gt;&gt; 
    : permits_heterogenous_lookup&lt;F&gt; {}; 
}</pre>

<p>But for current design it becomes more complicated. The user is required to declare <code>is_transparent</code> nested 
type in the definition of <code>call_wrapper&lt;F&gt;</code> if such type was defined in the <code>F</code> type.</p>
<pre>namespace detail 
{
  template&lt;typename F, typename IT = void&gt;
  struct is_transparent_base {};


  template&lt;typename F&gt;
  struct is_transparent_base&lt;F, void_t&lt;typename F::is_transparent&gt;&gt;
  {
    using is_transparent = typename F::is_transparent; 
  };
}

template&lt;typename F&gt;
struct call_wrapper : detail::is_transparent_base&lt;F&gt;
{ /*<i>...</i>*/ };</pre>

<p>In addition to being longer and intrusive, the nested type implementation requires of type <code>F</code> to 
be complete and becomes the point of instantiation of <code>call_wrapper&lt;F&gt;</code>.
As a consequence, it is impossible to create a reference wrapper class that would support both incomplete types and
heterogeneous container lookup.</p>

<h3><a name="motivation.consistency">Consistency with the Standard</a></h3>

<p>Proposed solution will make this functionality consistent with rest of the standard that relies on the usage
of the traits like: <code>is_placeholder</code> and <code>is_bind_expression</code> in similiar situations.</p> 


<h2><a name="design">Design Decisions</a></h2>

<h3><a name="design.semantics">Semantic of new trait</a></h3>

<p>Existing <code>is_transparent</code> nested was used to mark classes that has one of the following characteristics:</p>
<ol>
  <li>Transparently wraps operation expressed using build-in operators.</li>
  <li>Represents weak total order relation heterogeneous types and as consequence
  support lookup thought a different type.</li>
</ol>
<p>However we may point out existence of the types that does match one of above criteria. For example diamond version
<code>logical_not</code> or <code>plus</code> are transparently wrapping some build-in operators, but usually the cannot
be used as comparators. From the other side we may imagine the <code>icase_less</code> comparator that would provides
overloads for <code>std::string</code> and <code>char*</code>.</p>

<p>The trait proposed in this is designed to identify only the types in the second category. The relation with the
existing <code>is_transparent</code> is preserved only for backward compatibility reasons.</p>

<h3><a name="design.naming">Naming</a></h3>

<p>Following criteria was considered in the process of name selection for new metafunction:</p>
<ul>
  <li>The name should not be too generic, to not collide with existing trait or reserve name that would be more suitable in other context.
  Names that was rejected because of this criteria: <code>is_generic</code>, <code>is_polymorphic</code>, <code>is_transparent</code>.</li>
  <li>The name should match the semantics of the metafunction: if its returns true, the container specialized with given functor will expose
  heterogeneous lookup function, not the functor object itself.
  Names that was rejected because of this criteria: <code>supports_heterogeneous_lookup</code>, <code>provides_heterogeneous_lookup</code>,
  <code>allows_heterogeneous_lookup</code> and <code>enables_heterogeneous_lookup</code>.</li>
  <li>The name should allow usage of metafunction for future extension that may provide heterogeneous lookup for other container types
  like <code>unordered_set</code>, as consequence it should refer to concept of specific implementation.
  Names that was rejected because of this criteria: <code>is_heterogeneous_comparator</code>.</li>
  <li>The metafunction represents an opt-in functionality, so it is not automatically enabled for every functor thats support 
  heterogeneous comparison. As consequence set of types for which this functionality is enabled is subset of types that could be potentially
  used in this context.
  Names that was rejected because of this criteria: <code>is_compatible_with_heterogeneous_lookup</code>.</li>
</ul>

<p>This paper propose a new name for the trait <code>permits_heterogenous_lookup</code>, instead of keeping the name used for nested type.
This resolution was selected because the original name (<code>is_transparent</code>) is not acceptable, as it does not fulfill criteria
for a good name listed above.</p>

<h3><a name="design.backward-compatibility">Backward compatibility</a></h3>

<p>As the result of the introduction of <code>is_transparent</code> tag in the C++14 the design of <code>permits_heterogenous_lookup</code>
must carefully decide to choose one of the following:</p>   
  <ol>
    <li>Fix the pre-C++14 code compatibility problem that may be the result of silently enabling heterogeneous container lookup for
    existing comparators that have coincidentally provided the declaration of <code>is_transparent</code> nested type.
    To achieve that, the default implementation of the metafunction should always return false.</li>
    <li>Preserve the support for post-C++14 user-defined comparator types that intentionally enable heterogeneous
    container lookup via the declaration of <code>is_transparent</code> nested type. To achieve that, the default
    implementation of the metafunction should return true for the functors with this type present.</li>
  </ol>

<p>Considering the fact that we are addressing a rare problem, and the fact the harm was already done
(C++14 was shipped), the proposal decides to choose second option and provide the default implementation
that relies on presence of the nested type.</p>

<p>As a consequence of this decision, two ways of enabling heterogeneous lookup are provided by the standard:
via the declaration of the nested type, and the explicit specialization of the trait. The author strongly believes
that new mechanism provides an better alternative and decides to express it via non normative note.</p>

<h3><a name="design.header">Place of declaration</a></h3>

<p>The semantics of <code>permits_heterogeneous_lookup</code> new trait is directly related to the associative containers
and as consequence it would be preferred to declare it in related header. However currently no common utility header
for associative container is defined in the standard. Furthermore the scale of the proposed changes does not not justify
introduction of the new header. As consequence we propose that <code>permits_heterogeneous_lookup</code> should be included 
in <code>&lt;functional&gt;</code> header, as it contains definition of comparators that currently enables heterogeneous lookup.</p>

<h2><a name="standard">Impact On The Standard</a></h2>

<p>This proposal has no dependencies beyond a C++11 compiler and Standard Library implementation.</p>

<p>Nothing depends on this proposal.</p>


<h2><a name="feature-testing">Feature-testing recommendation</a></h2>

<p>For the purposes of SG10, we recommend the macro name <code>__cpp_lib_permits_heterogenous_lookup</code> to be defined in the
<code>&lt;functional&gt;</code> header.</p>

<h2><a name="wording">Proposed wording</a></h2>

<h2><a name="acknowledgements">Acknowledgements</a></h2>

<p>Jonathan Wakely provided an improved wording for the LWG issue #2430, from which this paper originates.</p>
<p>Andrzej Krzemieński offered many useful suggestions and corrections to the proposal.</p>


<h2><a name="literature">References</a></h2>

<ol>
<li>Marshall Clow, "C++ Standard Library Active Issues List (Revision R92)" (N4383, <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4383.html">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4383.html</a>)</li>
</ol>

</body></html>
