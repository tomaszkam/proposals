<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style type="text/css">
pre {margin-left:20pt; }
pre > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
pre > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table.header { border: 0px; border-spacing: 0;
  margin-left: 0px; font-style: normal; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none; 
  padding-right: 0.4em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none;
  padding-right: 0.4em; border: none; }
</style>

<title>Comments on P0119R0: Overload sets as function arguments</title>
</head>

<body>

<table class="header"><tbody>
  <tr>
    <th>Document number:&nbsp;&nbsp;<th> <td></td>
  </tr>
  <tr>
    <th>Date:&nbsp;&nbsp;<th> <td></td>
  </tr>
  <tr>
    <th>Project:&nbsp;&nbsp;<th> <td>Programming Language C++, Evolution Working Group</td>
  </tr>
  <tr>
    <th>Reply-to:&nbsp;&nbsp;<th> <td><address>Tomasz Kamiński &lt;tomaszkam at gmail dot com&gt;</address></td>
  </tr>
</tbody></table>

<h1><a name="title">Comments on P0119R0: Overload sets as function arguments</a></h1>

<h2><a name="intro">Introduction</a></h2>

<p>The aim of this paper is to present the authors comments on the impact of the change proposed in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0119r0.pdf">P0119R0: Overload sets as function arguments</a>.
At the begin I would like to qualify that I see a great need for a language level feature that would allow programmers
to easily create an lambda expression that wrap polymorphic calls to function with given name.</p>

<p>Observations and comments gathered in this paper are related to only one of aspect of the feature that makes the compiler
responsible for decision in which situation the lambda generation will actually be performed. As consequence all of 
them would be voided by using the design that would allow programmer explicitly request the generation of the functor
object. This may be achieved, for example by using <code>[]id-expression</code> syntax proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3617.htm">N3617: Lifting overload sets into function objects</a>
with keeping the same rules for functor generation.</p>


<!--h2><a name="toc">Table of contents</a></h2-->

<h2><a name="fragility">2. Fragility of the program semantics</a></h2>

<p>The wording presented in the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0119r0.pdf">P0119R0</a> 
paper makes the meaning of the <code>id-expression</code> passed as a argument for unconstrained template parameter,
depended on the if it represent overload sets.
This make the meaning of the programs depended on the order of declaration, and leads to situation when meaning of
the program is vastly changed, by even slight change, like reordering of the included headers.</p>

<h3><a name="fragility.example">Example program</a></h3>
<p>Let consider following example of program constructed out of following files:</p>

<p><b>File: <code>container1.hpp</code></b></p>
<pre>namespace cont
{
  class C1 //container
  {
    /* ... */
  };

  bool empty(C1 const&amp;);
};</pre>

<p><b>File: <code>container2.hpp</code></b></p>
<pre>namespace cont
{
  class C2 //container
  {
    /* ... */
  };

  bool empty(C2 const&);
};</pre>

<p><b>File: <code>remove_empty.hpp</code></b></p>
<pre>#include &lt;algorithm&gt;

namespace cont
{
  template&lt;typename I&gt;
  I remove_empty(I first, I last)
  { return std::remove(first, last, empty); //P: point of checking of visible overloads of empty.
};</pre>


<p><b>File: <code>main.cpp</code></b></p>
<pre>#include "container1.hpp"
#include "container2.hpp"
#include "remove_empty.hpp"

namespace my_cont
{
  class MC 
  {
    /* ... */
  };

  bool empty(MC const&);
};

int main()
{
  std::vector&lt;cont::C1&gt; vc1(10);
  cont::remove_empty(vc1.begin(), vc1.end()); // 1

  std::vector&lt;cont::C2&gt; vc2(10);
  cont::remove_empty(vc2.begin(), vc2.end()); // 2

  std::vector&lt;my_cont::MC&gt; vmc(10);
  cont::remove_empty(vmc.begin(), vmc.end()); // 3
}</pre>

<p>In the case of the above program, there will be two overloads of <code>empty</code> visible thought normal
lookup at the point of use of <code>empty</code> as template parameter (marked as //P).
This according to the wording presented on the paper lead to generation of the code equivalent to:</p>
<pre>
  template&lt;typename I&gt;
  I remove_empty(I first, I last)
  { return std::remove(first, last, [](auto&amp;&amp;... args) { return empty(std::forward&lt;decltype(args)&gt;(args)...); });
</pre>
<p>The lambda generated in place of <code>empty</code> identifier, performs the unqualified call of the function, 
so it will consider overloads of <code>empty</code> found by ADL. As consequence both lines marked as //1, //2 and //3 will compile,
while for the //3 line the <code>my_cont::empty</code> declaration will be found thought ADL.</p>

<p>However if the order of the includes in the <code>main.cpp</code> will be changed to:</p>
<pre>#include "container1.hpp"
#include "remove_empty.hpp"
#include "container2.hpp"</pre>
<p>At the point of //P only one declaration one of <code>empty</code> will be visible, so according to the wording paper, 
this will lead to generation of following code.</p>
<pre>
  template&lt;typename I&gt;
  I remove_empty(I first, I last)
  { return std::remove(first, last, &amp;empty); }
  //As the empty is not-overloaded, the <code>&amp;empty</code> is unambiguous and produces <code>bool (*)(cont::C1 const&amp;)</code> 
</pre>
<p>This resolution is selected to preserve backward compatibility that resolves <code>function-id</code> that points to single not overloaded function,
to function pointer. However as consequence of this change, the lines //1 and //3 will not longer compiler as both <code>cont::C2</code> and <code>my_cont::MC</code> 
will not be accepted as argument for <code>bool (*)(cont::C1 const&amp;)</code>.

<p>For similar reasons only line //2 will compile, if the header will be placed in following order:</p>
<pre>#include "container2.hpp"
#include "remove_empty.hpp"
#include "container1.hpp"</pre>

<p>Finally the program will produce error mentioning not unresolved name <code>empty</code>, if the header will be ordered as follows:</p> 
<pre>
#include "remove_empty.hpp"
#include "container1.hpp"
#include "container2.hpp"</pre>

<h3><a name="fragility.odr">ODR Violation</a></h3>

<p>The above example showed how the semantics of the same instantiation of the <code>filter_empty</code> changes depending of the order of the
headers in the program. However this only exposes an deeper problem with proposed resolution: depending on the order of the header included
in the transaction unit, the semantic of the same instantiation of <code>filter_empty</code> will change the meaning, with according to the standard
(14.6.4.1 [temp.point] p8) leads to the ill-formed programs.</p>

<p>It may be pointed out that similar problems already occurs in case of not-overloaded function. However the problem occurs only when situation
when the same name resolves to two different functions in different translation unit, so it may be considered as result of another violation of 
ODR.</p>

<h3><a name="fragility.summary">Summary</a></h3>

<p>As the above example shows up, the use of the feature of passing overloaded functions sets as template arguments inside of function template lead to 
fragile code that changes it meaning and validity depending on the subtle changes in the order of declarations (headers). This is caused by the fact
that generation of lambda in proposed functionality, depends only on normal lookup, and ignores ADL and two phase lookup that was created to avoid such 
problems in template code in first place.</p>


<h2><a name="usability">Scope and usability</a></h2>

<p>The aim <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0119r0.pdf">P0119R0</a>
is to make following code to be well formed when multiple overloads of function <code>f</code> are
found:</p>
<pre>template&lt;typename  I&gt;
void apply_f(I first, I last)
{
  transform(first, last, f);
}</pre>

<p>However this problem is only small fraction of more generic problem of creating a language feature that
would allow to provide a concise and optimal way, to pass an overloaded function name to generic component.</p>

<h3><a name="usability.ADL">Argument Depended Lookup</a></h3>

<p>Let consider following function example:</p>
<pre>template&lt;typename  I&gt;
I remove_empty(I first, I last)
{ return std::remove_if(first, last, [](auto const&amp; arg) { return empty(arg): }</pre>

<p>I think that it would be reasonable to expect that invocation of above function (and
function itself) can be replaced by the <code>std::remove_if(first, last, empty)</code> 
without any loss of efficiency and readability.</p>

<p>However, the call <code>std::remove_if(first, last, empty)</code> will be equivalent
to <code>remove_empty(first, last, empty)</code> only when the lambda will be generated 
in place of <code>empty</code> in case of first invocation. According to the paper,
this will only take place if declaration of <code>empty</code> found thought normal
lookup will represent overload set (multiple declarations or function template).
This may be not be the case for every place, where invocation <code>remove_empty(first, last, empty)</code>
compiled successfully, because as the unqalifed call to <code>empty(arg)</code> allow
overloads to be found by ADL.</p>

<h3><a name="usability.default-arguments">Default arguments</a></h3>

<p>In addition to usual means, like declaration of multiple overloads of single function name or declaring it
as function template, there is one additional way to create a function that can be called with more than one
set of arguments. We can declare function single function with default parameter:</p>
<pre>
void increment(int&amp; i, int n = 1)
{ i += 1; }
</pre>

<p>Lets imagine that our goal is to produce a <code>increment_all</code> function that will increment by all
elements in given range of integers. We could implement it using the <code>std::for_each</code> with 
<code>increment</code> passed as argument. I we try to use proposed feature in implementation:</p>
<pre>template&lt;typename I&gt;
void increment_all(I first, I last)
{
  std::for_each(first, last, increment);
}</pre>

<p>At the first glance, we could expect that in place of functor argument the following lambda will be
generated <code>[](auto&amp;&amp;... args) { return increment(std::forward&lt;decltype(args)&gt;(args)...); }</code>
and it will be invoked with only one <code>int&amp; i</code> argument, leading to following <code>increment(i)</code>.<p>

<p>However this will not be the case for proposed feature, as it makes the generation of the lambda depended
on the number of visible overloads of given function name. In our case we have only one declaration that can be
called with variable number of arguments so it does not fulfill above criteria and <code>void(*)(int&amp;, int)</code>
will be passed instead.</p>

<h3><a name="usability.indirect-call">Avoiding indirection thought function pointers</a></h3>

<p>Currently the call in the form <code>std::find_if(first, last, func)</code> compiles and works
correctly when the <code>func</code> can be unambiguously resolved to single function call.
In such situation function pointer will be passed to the invoked algorithm and indirect
call will be performed for each element. This is not changed in case of proposed feature to preserve
backward compatibility with old code.</p>

<h3><a name="usability.sumamry">Summary</a></h3>

<p>If we aim to provide language extension that will allow us to pass overloaded function name as functor to generic component,
we should desing most generic solution, that will cover vast majority of the uses, instead of single specific case. As presented
in the example above the functionality proposed in the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0119r0.pdf">P0119R0</a>
fails to achieve this goal.</p>



<h2><a name="acknowledgements">Acknowledgements</a></h2>

<p>I would like to thank Philipp Juschka for originally proposing the idea of lifting expression and Andrew Sutton for reopening the discussion on
this features. This paper is just mere commentary for their works.</p>
<!--p>Andrzej Krzemieński offered many useful suggestions and corrections to the proposal.</p-->


<h2><a name="literature">References</a></h2>

<ol>
<li>Andrew Sutton, "Overload sets as function arguments" (P0119R0, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0119r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0119r0.pdf</a>)</li>
<li>Philipp Juschka, "Lifting overload sets into function objects" (P0119R0, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3617.htm">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3617.htm</a>)</li>
</ol>

</body></html>
