<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html class="gr__open-std_org gr__isocpp_org"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style type="text/css">
pre {margin-left:20pt; }
pre > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
pre > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table.header { border: 0px; border-spacing: 0;
  margin-left: 0px; font-style: normal; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none; 
  padding-right: 0.4em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none;
  padding-right: 0.4em; border: none; }
</style>

<title>Adjusting meaning  <code>strided_slice::extent</code> to make it more generic</title>
</head>

<body data-gr-c-s-loaded="true">

<table class="header"><tbody>
  <tr>
   <th>Document number:&nbsp;&nbsp;</th><th> </th><td>DXXXXR0</td>
  </tr>
  <tr>
    <th>Date:&nbsp;&nbsp;</th><th> </th><td>2025-12-16</td>
  </tr>
  <tr>
    <th>Audience:&nbsp;&nbsp;</th><th> </th><td>Library Evolution Working Group</td>
  </tr>
  <tr>
    <th>Reply-to:&nbsp;&nbsp;</th><th> </th><td><address>Tomasz Kamiński &lt;tomaszkam at gmail dot com&gt;</address></td>
  </tr>
</tbody></table>

<h1><a name="title">Adjusting meaning  <code>strided_slice::extent</code> to make it more generic</a></h1>

<h2><a name="intro">1. Introduction</a></h2>

<p>This paper proposes to adjust the meaning of <code>strided_slice::extent</code> member,
   to contain the desired number of elements in produced range.</p>

<table>
  <tbody><tr>
    <th></th>
    <th>Before</th>
    <th>After</th>
  </tr>

  <tr>
    <td colspan="3">
<pre>void processFixed(std::span&lt;int, 5&gt;);
void processDynamic(std::span&lt;int&gt;);

std::vector&lt;int&gt; v3(3);
std::vector&lt;int&gt; v5(5);
</pre>
	</td>
  </tr>
  
  <tr>
    <td colspan="3">
      <p>Dynamic range with different size (5 vs 3)</p>
	</td>
  </tr>
  
  <tr>
    <td>
<pre>
processFixed(v3);                                             //
processFixed({v3.data(), v3.data() + 3});                     //

processFixed(span&lt;int, 5&gt;(v3));                               //
processFixed(span&lt;int, 5&gt;{v3.data(), v3.data() + 3});         //

processFixed(span&lt;int&gt;(v3).first&lt;5&gt;());                       //
processFixed(span&lt;int&gt;{v3.data(), v3.data() + 3}.first&lt;5&gt;()); //

span&lt;int, 5&gt; s = v3;                                          //
span&lt;int, 5&gt; s(v3);                                           //

span&lt;int, 5&gt; s = {v3.data(), v3.data() + 3};                  //
span&lt;int, 5&gt; s{v3.data(), v3.data() + 3};                     //
</pre>
    </td>

    <td>
<pre>
<font color="orange">ill-formed</font>
<font color="red">undefined-behavior</font>

<font color="orange">ill-formed</font>
<font color="red">undefined-behavior</font>

<font color="red">undefined-behavior</font>
<font color="red">undefined-behavior</font>

<font color="orange">ill-formed</font>
<font color="red">undefined-behavior</font>

<font color="red">undefined-behavior</font>
<font color="red">undefined-behavior</font></pre>
   </td>

    <td>
<pre>
<font color="orange">ill-formed</font>
<font color="orange">ill-formed</font>

<font color="red">undefined-behavior</font>
<font color="red">undefined-behavior</font>

<font color="red">undefined-behavior</font>
<font color="red">undefined-behavior</font>

<font color="orange">ill-formed</font>
<font color="red">undefined-behavior</font>

<font color="orange">ill-formed</font>
<font color="red">undefined-behavior</font></pre>
   </td>
  </tr>
  
<tr>
    <td colspan="3">
      <p>Dynamic range with matching size (5 vs 5)</p>
	</td>
  </tr>
  
  <tr>
    <td>
<pre>
processFixed(v5);                                             //
processFixed({v5.data(), v5.data() + 5});                     //

processFixed(span&lt;int, 5&gt;(v5));                               //
processFixed(span&lt;int, 5&gt;{v5.data(), v5.data() + 5});         //

processFixed(span&lt;int&gt;(v5).first&lt;5&gt;());                       //
processFixed(span&lt;int&gt;{v5.data(), v5.data() + 5}.first&lt;5&gt;()); //

span&lt;int, 5&gt; s = v5;                                          //
span&lt;int, 5&gt; s(v5);                                           //

span&lt;int, 5&gt; s = {v5.data(), v5.data() + 5};                  //
span&lt;int, 5&gt; s{v5.data(), v5.data() + 5};                     //
</pre>
    </td>

    <td>
<pre>
<font color="orange">ill-formed</font>
<font color="green">ok</font>

<font color="orange">ill-formed</font>
<font color="green">ok</font>

<font color="green">ok</font>
<font color="green">ok</font>

<font color="orange">ill-formed</font>
<font color="green">ok</font>

<font color="green">ok</font>
<font color="green">ok</font></pre>
   </td>

    <td>
<pre>
<font color="orange">ill-formed</font>
<font color="orange">ill-formed</font>

<font color="green">ok</font>
<font color="green">ok</font>

<font color="green">ok</font>
<font color="green">ok</font>

<font color="orange">ill-formed</font>
<font color="green">ok</font>

<font color="orange">ill-formed</font>
<font color="green">ok</font></pre>
   </td>
  </tr>
  
</tbody></table>
  

<h2><a name="history">2. Revision history</a></h2>

<h3><a name="history.r0">2.1. Revision 0</a></h3>

<p>Initial revision.</p>
   
<h2><a name="motivation">3. Motivation and Scope</a></h2>

<p>For the invocation of in the form <code>smd = submdspan(md, strided_slice{offset, extent, stride})</code>, 
  there are two ranges of indicies of elements that we are reffering to:</p>
  <ul>
    <li><i>input extent</i>: size of the range of indicies into <code>md</code>, that can be accessed <code>smd</code>,</li>
    <li><i>output extent</i>: size of the range of indicies that are valid indicies for <code>smd</code>.</li>
  </ul>
</p>

<p>Given the above, there are two possible interprentations of the <code>extent</code> for the above example,
  and <code>extent</code> can be interpreted as:
  <ul>
    <li><i>input extent</i>, thus <i>output extent</i> is <code>(extent - 1) / stride</code></li>
    <li><i>output extent</i>, thus <i>input extent</i> is <code>extent * stride</code></li>
  </ul>
</p>

<p>This two meanings are functionally equivalent as they can be transformed into each other,
  in majority of the cases. However, due use of the division in the <i>input extent</i> interpretation,
  in contrast to <i>output extent</i>, does not support following:
  <ul>
    <li><code>stride</code> of value of zero, that could be used to produce non-unique layouts,</li>
    <li>specifying the value of <i>output extent</i> statically, while keeping the index dynamic.</li>
  </ul>
</p>

<p>As <code>strided_slice</code> is used as one of the cannonical forms of the slices,
 we propose to <code>strided_slice::extent</code> member should represent <i>output extent</i>.</p>
   
<h3><a name="motivation.range_slice">3.1. Introducing <code>range_slice</code> and extending decomposable slices</a></h3>

<p>One of the argument of the for uses of the <i>input extent</i> as <code>stride_slice::extent</code>
  value, was consistency with the interface provided for range slicing in the other languges.
  However, from the survey of the interface in most common languages shows that <code>first, last</code>
  range is used instead of <code>offset, length</code>:
  <ul>
   <li><a href="https://fortran-lang.org/learn/quickstart/arrays_strings/">Fortran</a>:
       <code>array(first:lasst)</code> and <code>array(first:last:step)</code>,</li>
   <li><a href="https://docs.python.org/3/library/functions.html#slice">python</a>:
       <code>array[first:last]</code> and <code>array[first:last:step]</code>,</li>
   <li><a href="https://docs.python.org/3/library/functions.html#slice">rust</a>:
       <code>array[first..last]</code>, <code>array[first..]</code>, <code>array[..last]</code> and <code>array[..]</code>.</li>
  </ul>
  Based on the other languages, the <code>submdspan(md, strided_slice{2, 5, 1})</code>,
  should select elements <code>[2, 5)</code>, instead of <code>[2, 7)</code> as currently specified.
</p>

<p>To provide a interface consistient with existing practice in other language, we propose
  extension to set of acceptable slice type to types that decompose into tree values that
  are compatible with index type. So in addition to accepting pairs (including two element
  <code>tuple</code>) representing selection of <code>first, last</code>, we propose to
  accept a tree elements tuples, where third value determines stride.</code>

<p>Futhermore we proposed to introduce vocabluary type for "range" slice:</p>
<pre>
template&lt;typename FirstType, typename LastType, typename StrideType = constant_wrapper&lt;1zu&gt;&gt;
  struct range_slice
  {
    [[no_unique_addresss] FirstType first{};
    [[no_unique_addresss] LastType last{};
    [[no_unique_addresss] StrideType stride{};
  };
</pre>

<h3><a name="motivation.static-extent">3.2. Example of static <i>output extent</i> usage</a></h3>

<p>As mentioned before using current <i>input extent</i> specification does not allow
  selecting a statically sized subset of elements with dynamic stride. For example, let's 
  imagine that we want to select 5 elements, evenly spaced from the <code>mdspan md</code>.</p>

<p>With proposed change, we can simply express that as:</p>
<pre>
  auto smd = sumdspan(md, strided_slice{cw&lt;0&gt;, cw&lt;5&gt;, md.extents()[0] / 5})
</pre>

<p>Note that the number of number of elements in the <code>smd</code> is always know
   statically, regardless if source span had static extents.</p>


<h3><a name="motivation.static-extent">3.3. Example of zero stride value usage</a></h3>

<p>Using a zero as the value of the <code>stride</code> leads to non-unique mappings
  (incrementing the index does not change the referenced element), thus they are not
  accepted by standard mappings.<p>

<p>However, <code>submdspan</code> can be also used with <code>mdspan</code> with
  user defined mappings, that are not required to be unique, and any mapping can
  be queried (<code>is_always_unique</code>, <code>is_unique</code>) for this property.</p>

<p>One could imagine <code>layout_strided_nonunique</code> layout, that is equivalent
  to <code>layout_strided</code>, except that it does not require that provided strides,
  lead to non-unique mapping. In case of <code>mdspan</code> with such mapping, stride
  of value zero may be used to create layout that boardcast single element:</p>
<pre>
  auto smd = submdspan(md, strided_slice{3, 5, 0};
</pre>
<p>For above example <code>smd[0], smd[1], ..., smd[4]</code> each result in reference
  to <code>md[3]</code>.</p>

<p>As mentioned before such slice specification is not representable to currently.
   While the paper does not lift current preconditions on stride value being non-zero,
   it allows such strides to be allowed in future.</p>

<h2><a name="impact">4. Impact and Implementability</a></h2>

<h2><a name="wording">5. Proposed Wording</a></h2>

<p>The proposed wording changes refer to <a href="http://wg21.link/n5032"></a> N5032 (C++ Working Draft, 2025-12-15).</p>

<p>Apply following changes to section [span.overview] Overview:</p>
<blockquote class="std">
<pre>
   // [span.cons], constructors, copy, and assignment
   constexpr span() noexcept;
   template&lt;class It&gt;
     constexpr <ins>explicit(extent != dynamic_extent)</ins> span(It first, size_type count);
   template&lt;class It, class End&gt;
     constexpr <ins>explicit(extent != dynamic_extent)</ins> span(It first, End last);
   template&lt;size_t N&gt; 
     constexpr span(element_type (&arr)[N]) noexcept;
   template&lt;size_t N&gt; 
     constexpr span(array&lt;value_type, N&gt;& arr) noexcept;
   template&lt;size_t N&gt; 
     constexpr span(const array&lt;value_type, N&gt;& arr) noexcept;
   template&lt;class R&gt;
     constexpr <ins>explicit(extent != dynamic_extent)</ins> span(R&amp;&amp; r);
   constexpr span(const span& other) noexcept = default;
   template&lt;class OtherElementType, size_t OtherExtent&gt;
     constexpr <ins>explicit(<em>see below</em>)</ins> span(const span&lt;OtherElementType, OtherExtent&gt;&amp; s) noexcept;</pre>
</pre>
</blockquote>


<p>Apply following changes to section [mdspan.sub.overview] Overview :</p>
<blockquote class="std">

  <dl class="attribute">
    <dd><p>-1- The <code>submdspan</code> facilities create a new <code>mdspan</code>
    viewing a subset of elements of an existing input <code>mdspan</code>.
    The subset viewed by the created mdspan is determined by the
    <code>SliceSpecifier</code> arguments.</p></dd>

    <dd><p>-2- Given a signed or unsigned integer type <code>IndexType</code>, a
    type <code>S</code> is a <i></code>submdspan</code> slice type for <code>IndexType</code></i>
    if at least one of the following holds:<ul>
      <li>-2.1- <code>is_convertible_v&lt;S, full_extent_t&gt;</code> is <code>true</code>;</li>
      <li>-2.2- <code>is_convertible_v&lt;S, IndexType&gt;</code> is <code>true</code>;</li>
      <li>-2.3- <code>S</code> a specialization of <code>strided_slice</code> and 
      <code>is_convertible_v&lt;<i>X</i>, IndexType&gt;</code> is <code>true</code>
      for <code><i>X</i></code> denoting <code>S::offset_type</code>, <code>S::extent_type</code>,
      and <code>S::stride_type;</code> or</li>
      <li>-2.4- all of the following hold:<ul>
        <li>-2.4.1- the declaration <code>auto [...ls] = std::move(s);</code> is
             well-formed for some object <code>s</code> of type <code>S</code>,</li>
	<li>-2.4.2- <code>sizeof...(ls)</code> is equal <ins>either</ins> to <code>2</code><ins> or <code>3</code></ins>, and</li>
	<li>-2.4.3- <code>(is_convertible_v&lt;decltype(std::move(ls)), IndexType&gt; &amp;&amp; ...)</code> is <code>true</code>.
      </ul></li>
    </ul></p></dd>

    <dd><p>-3- Given a signed or unsigned integer type <code>IndexType</code>,  a type <code>S</code> is a
      <i>canonical <code>submdspan</code> index type for <code>IndexType</code></i>
      if <code>S</code> is either <code>IndexType</code> or <code>constant_wrapper&lt;v&gt;</code>
      for some value <code>v</code> of type <code>IndexType</code>, such that <code>v</code> is greater
      than or equal to zero.</p></dd>

    <dd><p>-4- Given a signed or unsigned integer type <code>IndexType</code>, a type <code>S</code>
      is a <i>canonical <code>submdspan</code> slice type for <code>IndexType</code></i> if exactly one
      of the following is <code>true</code>:<ul>
      <li>-4.1- <code>S</code> is <code>full_extent_t</code>;</li>
      <li>-4.2- <code>S</code> is a canonical submdspan index type for
	<code>IndexType</code>; or</li>
      <li>-4.3- <code>S</code> a specialization of <code>strided_slice</code>
        where all of the following hold:<ul>
	<li>-4.3.1- <code>S::offset_type</code>, <code>S::extent_type</code>, and <code>S::stride_type</code>
	  are all canonical submdspan index types for <code>IndexType</code>; and</li>
	<li>-4.2.2- if <code>S::stride_type</code> and <code>S::extent_type</code>
     	 are both specializations of <code>constant_wrapper</code>, then
	 <code>S::stride_type::value</code> is greater than zero.</li>
      </ul></li>
    </ul></p></dd>

    <dd><p>-5- A type <code>S</code> is a <i>collapsing slice type</i> if [&hellip;]
    </p></dd>
 
    <dd><p>-6- A type <code>S</code> is a <i>unit-stride slice type</i> if [&hellip;]
    </p></dd>
  
    <dd><p>-7- Given an object <code>e</code> of type <code>E</code> that is a
      specialization of <code>extents</code>, and an object <code>s</code> of
      type <code>S</code> that is a canonical submdspan slice type for <code>E::index_type</code>,
      the <i><code>submdspan</code> slice range of <code>s</code> for the <i>k<sup>th</sup></i> extent of <code>e</code></i>
      is:<ul>
      <li>-7.1- <code>[0, e.extent(<i>k</i>))</code>, if <code>S</code> is <code>full_extent_t</code>;</li>
      <li>-7.2- <code>[E::index_type(s.offset), E::index_type(s.offset + s.extent <ins>* s.stride</ins>))</code>,
	if <code>S</code> is a specialization of <code>strided_slice</code>; otherwise</li>
      <li>-7.3- <code>[E::index_type(s), E::index_type(s)+1)</code></li>
      </ul></li>
    </ul></p></dd>

    <dd><p>-8- Given a type <code>E</code> that is a specialization of <code>extents</code>,
    a type <code>S</code> is a <i>valid <code>submdspan</code> slice type for the <i>k<sup>th</sup></i>
    extent of <code>E</code></i> if <code>S</code> is a canonical slice type for <code>E::index_type</code>,
    and for <code><i>x</i></code> equal to <code>E::static_extent(<i>k</i>)</code>, either <code><i>x</i></code>
    is equal to <code>dynamic_extent</code>; or<ul>
      <li>-8.1- if <code>S</code> is a specialization of <code>strided_slice</code>:<ul>
        <li>-8.1.1.- if <code>S::offset_type</code> is a specialization of <code>constant_wrapper</code>,
	  then <code>S::offset_type::value</code> is less than or equal to <code><i>x</i></code>;</li>
	<li>-8.1.2.- if <code>S::<del>offset_type</del><ins>stride_type</ins></code> is a specialization of
	  <code>constant_wrapper</code>, then <code>S::<del>extent_type</del><ins>stride_type</ins>::value</code>
	  is <del>less than or equal to <code><i>x</i></code></del><ins>greater than zero</ins>;</del>
	</li>
	<li>-8.1.3- if both <code>S::<del>offset_type</del><ins>extent_type</ins></code> and 
	  <code>S::<del>extent_type</del><ins>stride_type</ins></code> are specializations of
	  <code>constant_wrapper</code>, <ins>let <tt><i>r</i></tt> be <code>S::stride_type * S::extent_type</code></ins>,
	  then<ul>
	  <li><ins>-8.1.3.1- <tt><i>r</i></tt> is less than or equal to <code><i>x</i></code>, and</ins></li>
	  <li><ins>-8.1.3.2- if <code>S::offset_type</code> is specialization of <code>constant_wrapper</code>, then</ins>
	    <code>S::offset_type::value + <del>S::extent_type::value</del><ins><i>r</i></ins></code> is less than or equal to x; or</li>
	</ul></li>
      </ul></li>
      <li>-8.2- if <code>S</code> is a specialization of <code>constant_wrapper</code>,
      then <code>S::value</code> is less than <code><i>x</i></code></li>
    </ul></p></dd>

    <dd><p>-9- Given an object <code>e</code> of type <code>E</code> that is a specialization of 
      <code>extents</code> and an object <code>s</code> of type <code>S</code>, <codE>s</code>
      <i>is a valid <code>submdspan</code> slice for the k<sup>th</sup> extent of <code>e</code></i> if:<ul>
      <li>-9.1- <code>S</code> is a valid <code>submdspan</code> slice type for <i>k<sup>th</sup></i>
	  extent of <code>E</code>;</li>
      <li>-9.2- the <i>k<sup>th</sup></i> interval of <code>e</code> contains the <code>submdspan</code>
          slice range of <code>s</code> for the <i>k<sup>th</sup></i> extent of <code>e</code>; and</li>
      <li>-9.3- if <code>S</code> a specialization of <code>strided_slice</code> then:<ul>
	<li>-9.3.1- <code>s.extent</code> is greater than or equal to zero, and</li>
	<li>-9.3.2- <del>either <code>s.extent</code> equals zero or</del> <code>s.stride</code> is greater than zero.</li>
      </ul></li>
    </ul></p></dd>

  </dl>

</blockquote>

<p>Apply following changes to section [mdspan.sub.strided.slice] <code>strided_slice</code>:</p>

<blockquote class="std">
  
<h4>23.7.3.7.2 <del><code>strided_slice</code></del><ins>Range slices</ins> <span style="float:right">[mdspan.sub.strided.slice]</span></a></h4>

  <dl class="attribute">

    <dd>-1- <code>strided_slice</code><ins> and <code>range_range</code></ins> represent<del>s</del> 
      a set of extent regularly spaced integer indices. The indices start at <code>offset</code>
      <ins>and <code>first</code> respectively</ins>, and increase by increments of 
      <code>stride</code>.</dd>
  </dl>

  <pre>  namespace std {
    template&lt;class OffsetType, class ExtentType, class StrideType&gt;
    struct strided_slice {
      using offset_type = OffsetType;
      using extent_type = ExtentType;
      using stride_type = StrideType;

      [[no_unique_address]] offset_type offset{};
      [[no_unique_address]] extent_type extent{};
      [[no_unique_address]] stride_type stride{};
    };

<ins>    template&lt;class FirstType, class LastType, 
                     class StrideType = std::constant_wrapper&lt;1zu&gt;&gt;
    struct range_slice {
      using first_type = FirstType;
      using last_type = LastType;
      using stride_type = StrideType;

      [[no_unique_address]] first_type first{};
      [[no_unique_address]] last_type last{};
      [[no_unique_address]] stride_type stride{};
    };</ins>
  }
</pre>

  <dl class="attribute">

    <dd>-2- <code>strided_slice</code><ins> and <code>range_slice</code></ins> <del>has</del>
      <ins>have</ins> the data members and special members specified above. <del>It has</del>
      <ins>They have</ins> no base classes or members other than those specified.
    <p></p></dd>

    <dt>-3- Mandates:</dt>
    <dd><code>OffsetType</code>, <code>ExtentType</code><ins>, <code>FirstType</code>,
      <code>LastType</code></ins>, and <code>StrideType</code> are signed or unsigned integer
      types, or model <code><i>integral-constant-like</i></code>.
    <p></p></dd>

    <dd>[ <i>Note</i>: <ins>Both </ins><code>strided_slice{ .offset = 1, .extent = 
    <del>10</del><ins>4</ins>, .stride = 3}</code><ins> and <code>range_slice{
    .first = 1, .last = 11, .stride = 3}</code> indicate</del>s</del> the indices
    <code>1</code>, <code>4</code>, <code>7</code>, and <code>10</code>. Indices are
    selected from the half-open interval <code>[1, 1 + 10)</code>. — <ins>end note</ins>]
  </dl>  
  
</blockquote>

<p>Apply following changes to section [mdspan.sub.helpers] Exposition-only helpers:</p>

<blockquote class="std">
<pre>    templatelt&;class IndexType, class S&gt;
      constexpr auto canonical-index(S s);</pre>

  <dl class="attribute">
    <dt>-3- Mandates:</dt>
    <dd>[&hellip;];<p></p></dd>

    <dt>-4- Preconditions:</dt>
    <dd>[&hellip;];<p></p></dd>

    <dt>-5- Effects:</dt>
    <dd>[&hellip;];<p></p></dd>
  </dl>
    

<ins>
<pre>    template&lt;class IndexType, class OffsetType, class SpanType, class... StrideTypes&gt;
      constexpr auto <i>canonical-range-slice</i>(OffsetType offset, SpanType span, StrideTypes.. strides);</pre>

  <dl class="attribute">
    <dd>-?- Let:<ul>
      <li><code>StrideType</code> be <code>constant_wrapper&lt;IndexType(1)&gt;</code>
        if <code>sizeof...(StrideTypes) == 0</code> or <code>SpanType</code> denotes
        <code>constant_wrapper&lt;IndexType(0)&gt;</code>, and
	<code>StridesTypes...[0]</code> otherwise;</li>
      <li><code>stride</code> be<ul>
        <li><code>StrideType()</code> if <code>StrideType</code> is specialization
	  of <code>constant_wrapper</code>, otherwise</li>
	<li><code>IndexType(1)</code> if <code>span == 0</code> is <code>true</code>,
	  otherwise</li>
	<li><code>strides...[0]</code>;</li>
      </ul></li>
      <li><code><i>extent-value</i></code> be <code>1 + (span - 1) / stride</code>
        if <code>span != 0</code> is <code>true</code>, and <code>0</code> otherwise;</li>
      <li><code>extent</code> be <code>cw&lt;IndexType(<i>extent-value</i>)&gt;</code> if
	both <code>SpanType</code> and <code>StrideType</code> are specializations of
	<code>constant_wrapper</code>, and <code>IndexType(<i>extent-value</i>)</code>
	otherwise.</li>
    </ul><p></p></dd>
  
    <dt>-?- Mandates:</dt>
    <dd><br/><ul>
      <li><code>sizeof..(StrideTypes) &lt;= 1</code> is <code>true</code>, and</li>
      <li>if <code>StrideType</code> is specialization of <code>constant_wrapper</code>,
        then <code>stride &gt; 0</code> is <code>true</code>.</li>
    </ul><p></p></dd>
   
    <dt>-?- Preconditions:</dt>
    <dd><code>span == 0 || stride &gt;= 0</code> is <code>true</code>.<p></p></dd>

    <dt>-?- Returns:</dt>
    <dd>
      <code>strided_slice{ .offset = first, .extent = extent, .stride = stride };</code>
    <p></p></dd>

   </dl>
</ins>

<pre>    template&lt;class IndexType, class S&gt;
      constexpr auto <i>canonical-slice</i>(S s);</pre>

  <dl class="attribute">
    <dt>-6- Mandates:</dt>
    <dd>
      <code>S</code> is a <code>submdspan</code> slice type for <code>IndexTye.</code>
    <p></p></dd>

    <dt>-7- Effects:</dt>
    <dd>Equivalent to:<pre>
    if constexpr (is_convertible_v&lt;S, full_extent_t&gt;) {
      return static_cast&lt;full_extent_t&gt;(std::move(s));
    } else if constexpr (is_convertible_v&lt;S, IndexType&gt;) {
      return canonical-index&lt;IndexType&gt;(std::move(s));
    } else if constexpr (is-strided-slice&lt;S&gt;) {
      auto c_extent = canonical-index&lt;IndexType&gt;(std::move(s.extent));
      auto c_offset = canonical-index&lt;IndexType&gt;(std::move(s.offset));
      if constexpr (is_same_v&lt;decltype(c_extent), constant_wrapper&lt;IndexType(0)&gt;&gt;) {
        return strided_slice{
          .offset = c_offset,
          .extent = c_extent,
          .stride = cw&lt;IndexType(1)&gt;
         };
      } else {
         return strided_slice{
           .offset = c_offset,
           .extent = c_extent,
           .stride = canonical-index&lt;IndexType&gt;(std::move(s.stride));
	 };
       }
    } else {
      auto [s_first, s_last<ins>, ...s_stride</ins>] = std::move(s);
      auto c_first = canonical-index&lt;IndexType&gt;(std::move(s_first));
      auto c_last  = canonical-index&lt;IndexType&gt;(std::move(s_last));
      <del>return strided_slice{
          .offset = c_first,
          .extent = canonical-index&lt;IndexType&gt;(c_last - c_first),
          .stride = cw&lt;IndexType(1)&gt;
        };</del>
      <ins>return <i>canonical-slice-range</i>&lt;IndexType&gt;(
               c_first,
	       canonical-index&lt;IndexType&gt;(c_last - c_first),
	       canonical-index&lt;IndexType&gt;(std::move(s_stride))...);</ins>
    }
    </pre></dd>

  </dl>
  
</blockquote>

<blockquote class="std">
  <dl class="attribute">
    <dt>Preconditions:</dt>
    <dd>&nbsp;
    <ul>
	  <li>If <code>extent</code> is not equal to <code>dynamic_extent</code>, then <code>last - first</code> is equal to <code>extent</code>.</li>
      <li><code>[first, first + count)</code> is a valid range.</li>
      <li><code>It</code> models <code>contiguous_iterator</code>.</li>
	  <li><code>End</code> models <code>sized_sentinel_for&lt;It&gt;</code>.</li>
    </ul>
    <p></p></dd>

    <dt>Effects:</dt>
    <dd>Initializes <code>data_</code> with <code>to_address(first)</code> and <code>size_</code> with <code>last - first</code>.<p></p></dd>

    <dt>Throws:</dt>
    <dd>When and what <code>to_address(first)</code> throws.<p></p></dd>
  </dl>
  
<pre>   template&lt;size_t N&gt; constexpr span(element_type (&arr)[N]) noexcept;
   template&lt;size_t N&gt; constexpr span(array&lt;value_type, N&gt;& arr) noexcept;
   template&lt;size_t N&gt; constexpr span(const array&lt;value_type, N&gt;& arr) noexcept;</pre>

  <dl class="attribute">
    <dt>Constraints:</dt>
    <dd><ins>Let <code>U</code> be <code>remove_pointer_t&lt;decltype(data(arr))&gt;</code>.</ins>
    <ul>
	  <li><code>extent == dynamic_extent || N == extent</code> is <code>true</code>, and</li>
	  <li><del><code>remove_pointer_t&lt;decltype(data(arr))&gt;(*)[]</code> is convertible to <code>ElementType(*)[]</code>.</del></li>
      <li><ins><code>is_convertible_v&lt;U(*)[], element_type(*)[]&gt;</code> is <code>true</code>.
	      [Note: The intent is to allow only qualification conversions of the iterator reference type to <code>element_type</code>. — end note]</ins></li>
	</ul>
    <p></p></dd>

    <dt>Effects:</dt>
    <dd>Constructs a <code>span</code> that is a view over the supplied array..<p></p></dd>

    <dt>Postconditions:</dt>
    <dd><code>size() == N && data() == data(arr)</code><p></p></dd>
  </dl>
  
<pre>   template&lt;class R&gt;
     constexpr <ins>explicit(extent != dynamic_extent)</ins> span(R&amp;&amp; r);</pre>

  <dl class="attribute">

    <dt>Constraints:</dt>
    <dd>Let <code>U</code> be <code>remove_reference_t&lt;ranges::range_reference_t&lt;R&gt;&gt;</code>.
    <ul>
	  <li><del><code>extent == dynamic_extent</code> is <code>true</code>.</del></li>
	  <li><code>R</code> satisfies <code>ranges::contiguous_range</code> and <code>ranges::sized_range</code>.</li>
	  <li>Either <code>R</code> satisfies <code>safe_range</code> or <code>is_const_v&lt;element_type&gt;</code> is <code>true</code>.</li>
	  <li><code>remove_cvref_t&lt;R&gt;</code> is not a specialization of <code>span</code>.</li>
	  <li><code>remove_cvref_t&lt;R&gt;</code> is not a specialization of <code>array</code>.</li>
	  <li><code>is_array_v&lt;remove_cvref_t&lt;R&gt;&gt;</code> is <code>false</code>.</li>
      <li><code>is_convertible_v&lt;U(*)[], element_type(*)[]&gt;</code> is <code>true</code>.
	      [Note: The intent is to allow only qualification conversions of the iterator reference type to <code>element_type</code>. — end note]</li>
    </ul>
    <p></p></dd>

    <dt>Preconditions:</dt>
    <dd>&nbsp;
    <ul>
	  <li><ins>If <code>extent</code> is not equal to <code>dynamic_extent</code>, then <code>ranges::size(r)</code> is equal to <code>extent</code>.</ins></li>
      <li><code>R</code> models <code>ranges::contiguous_range</code> and <code>ranges::sized_range</code>.</li>
	  <li>If <code>is_const_v&lt;element_type&gt;</code> is <code>false</code>, <code>R</code> models <code>safe_range</code>.</li>
    </ul>
    <p></p></dd>

    <dt>Effects:</dt>
    <dd>Initializes <code>data_</code> with <code>ranges::data(r)</code> and <code>size_</code> with <code>ranges::size(r)</code>.<p></p></dd>

    <dt>Throws:</dt>
    <dd>What and when <code>ranges::data(r)</code> and <code>ranges::size(r)</code> throws.<p></p></dd>
  </dl>
  
[...]
  
<pre>   template&lt;class OtherElementType, size_t OtherExtent&gt;
     constexpr <ins>explicit(<em>see below</em>)</ins> span(const span&lt;OtherElementType, OtherExtent&gt;&amp; s) noexcept;</pre>

  <dl class="attribute">

    <dt>Constraints:</dt>
    <dd>&nbsp;
    <ul>
	  <li><code><del>Extent</del><ins>extent</ins> == dynamic_extent 
	      <ins>|| OtherExtent == dynamic_extent</ins> 
		  || <del>Extent</del><ins>extent</ins> == OtherExtent</code> is <code>true</code>, and</li>
	  <li><del><code>OtherElementType(*)[]</code> is convertible to <code>ElementType(*)[]</code>.</del></li>
      <li><ins><code>is_convertible_v&lt;OtherElementType(*)[], element_type(*)[]&gt;</code> is <code>true</code>.
	      [Note: The intent is to allow only qualification conversions of the iterator reference type to <code>element_type</code>. — end note]</ins></li>
	</ul>
    <p></p></dd>

    <dt><ins>Preconditions</ins>:</dt>
    <dd><ins>If <code>extent</code> is not equal to <code>dynamic_extent</code>, then <code>s.size()</code> is equal to <code>extent</code>.</ins></li>
    <p></p></dd>

    <dt>Effects:</dt>
    <dd>Constructs a <code>span</code> that is a view over the range <code>[s.data(), s.data() + s.size())</code>.<p></p></dd>

    <dt>Postconditions:</dt>
    <dd><code>size() == other.size() && data() == other.data()</code><p></p></dd>

    <dt><ins>Remarks</ins>:</dt>
    <dd><ins>The expression inside <code>explicit</code> is equivalent to: <code>extent != dynamic_extent && OtherExtent == dynamic_extent</code>.</ins><p></p></dd>
  </dl>  
  
</blockquote>

<p>Update the value of the <code>__cpp_lib_span</code> in [version.syn] Header <code>&lt;version&gt;</code> synopsis to reflect the date of approval of this proposal.</p>


<h2><a name="acknowledgements">6. Acknowledgements</a></h2>

<!--p>Special thanks and recognition goes to Sabre (<a href="http://www.sabre.com/">http://www.sabre.com</a>) for supporting the production of this proposal
   and author's participation in standardization committee.</p-->
   
<h2><a name="literature">7. References</a></h2>

<ol>
  <li>Poland,
      "PL250 22.07.3.2 [span.cons] size mismatch for fixed-sized span",
	  (PL250, <a href="https://github.com/cplusplus/nbballot/issues/246">https://github.com/cplusplus/nbballot/issues/246</a>)</li>

  <li>Stephan T. Lavavej,
      "span's Container constructors need another constraint",
	  (LWG3103, <a href="https://wg21.link/lwg3101">https://wg21.link/lwg3103</a>)</li>
		
  <li>Corentin Jabot, Casey Carter,
      "Range constructor for <code>std::span</code>",
	  (P1394R4, <a href="https://wg21.link/p1394r4">https://wg21.link/p1394r4</a>)</li>
		 
  <li>Corentin Jabot, Casey Carter,
      "A SFINAE-friendly trait to determine the extent of statically sized containers"
      (P1419R0, <a href="https://wg21.link/p1419r0">https://wg21.link/p1419r0</a>)</li>
	  
  <li>Richard Smith,
      "Working Draft, Standard for Programming Language C++"
      (N4842, <a href="https://wg21.link/n4842">https://wg21.link/n4842</a>)</li>

</ol>


</body></html>
