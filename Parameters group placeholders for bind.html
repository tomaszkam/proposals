<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style type="text/css">
pre {margin-left:20pt; }
pre > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
pre > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table.header { border: 0px; border-spacing: 0;
  margin-left: 0px; font-style: normal; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none; 
  padding-right: 0.4em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none;
  padding-right: 0.4em; border: none; }
</style>

<title>Parameters group placeholders for bind</title>
</head>

<body>

<table class="header"><tbody>
  <tr>
    <th>Document number:&nbsp;&nbsp;<th> <td></td>
  </tr>
  <tr>
    <th>Date:&nbsp;&nbsp;<th> <td>2014-07-12</td>
  </tr>
  <tr>
    <th>Project:&nbsp;&nbsp;<th> <td>Programming Language C++, Library Evolution Working Group</td>
  </tr>
  <tr>
    <th>Reply-to:&nbsp;&nbsp;<th> <td><address>Tomasz Kamiński &lt;tomaszkam at gmail dot com&gt;</address></td>
  </tr>
</tbody></table>

<h1><a name="title">Parameters group placeholders for bind</a></h1>

<h2><a name="intro">Introduction</a></h2>

<p>TODO: bug report from isocpp</p>

<!--h2><a name="toc">Table of contents</a></h2-->

<h2><a name="motivation">Motivation and Scope</a></h2>

<p>Before going thought this chapter the author recommends reader to familiarize with 
<a href="#appendix.bind_vs_lambda">Appendix: Why we need bind when we have a generic lambda?</a>.</p>

<p>TODO: proposal from M. Semenov, motivation for _from bind(f, _2, _1, _from&lt;3&gt;), </p>

<h2><a name="design">Design Decisions</a></h2>

<h3><a name="design.variable-templates">Use of variables templates to define placeholders</a></h3>

<p>The variable templates are used to define placeholders instead of set of extern variables. This approach allows
the programmer to compute positions of passed parameters at compile time, which is cumbersome in case of existing placeholders.
In addition the author finds single definition of <code>_from</code>, instead list of <code>_1onwards, _2onwards, ..., _Nonwards</code>,
being more elegant.</p>

<p>To complement set of group placeholders, the variable template version of single argument placeholder named <code>_at&lt;N&gt;</code>
is also introduced in this paper.</p>

<h3><a name="design.names">Naming of placeholders</a></h3>

<p>Parameter group placeholder proposed in this paper has names that begins with underscore (<code>_all</code>, <code>_from</code>)
   instead of the most obvious <code>all</code>, <code>from</code>. These names was chosen to reduce risk name collision in code,
   that uses <code>bind</code> in combination with using directive for <code>std::placeholders</code> namespace. Example:</p>
<pre>
  std::vector&lt;std::string&gt; erase_empty(std::vector&lt;std::string&gt; v)
  {
    using namespace std;
    using namespace std::placeholders;

    auto from = remove_if(begin(v), end(v), bind(&amp;string::empty, _1));
    v.erase(from, end(v));
    return v;
  }
</pre>

<p>Furthermore the author perceive this names as more consistent with the existing numbered placeholders (<code>_1</code>, <code>_2</code>, ...).</p>

<h3><a name="design.from">Number of parameters required by <code>_from&lt;N&gt;</code></a></h3>

<p>The addition of the <code>_from&lt;N&gt;</code> placeholder opens the question about its behaviour if the number of parmeters 
   passed to the forwarding call wrapper produced as a result of <code>bind(&amp;foo, _from&lt;N&gt;)</code> is equal to <code>N-1</code>.</p>

<p>There are two possible approaches:</p>
<ol>
  <li>forward no arguments in place of <code>_from&lt;N&gt;</code> to target callable object.</li>
  <li>make such invocation ill-formed and require at least <code>N</code> arguments if the <code>_from&lt;N&gt;</code> is used,</li>
</ol>
<p>The first behaviour was choosen by this proposal, because it allows to easily simulate the second one by passing <code>_N, _from&lt;N+1&gt;</code>
   insteaf of <code>_from&lt;N&gt;</code> as argument.</p>
   
<h3><a name="design.int-index">Non-type template argument of type <code>int</code></a></h3>

<p>The non-type template argument of <code>_from</code>, <code>parameter_indexes</code> has an <code>int</code> type, although they values
   are required to be non-negative. This design decision was made to keep them consistent with existing <code>is_placeholder</code>
   trait, that uses <code>int</code> to represent index of forwarder parameter.</p>

<h2><a name="standard">Impact On The Standard</a></h2>

<p>This proposal has no dependencies beyond a C++14 compiler and Standard Library implementation. 
   (It depends on perfect forwarding, varidatic templates, variable templates, <code>decltype</code> and trailing return types.)</p>

<p>Nothing depends on this proposal.</p>

<h2><a name="wording">Proposed wording</a></h2>

<p>Change the section 20.10 [function.objects]/2.</p>

<blockquote class="std"> 
<pre>
// 20.10.9, <em>bind</em>:
template&lt;class T&gt; struct is_bind_expression;
template&lt;class T&gt; struct is_placeholder;
<ins>template&lt;class T, int N&gt; struct parameter_indexes;</ins>

template&lt;class F, class... BoundArgs&gt;
  <em>unspecified</em> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);
template&lt;class R, class F, class... BoundArgs&gt;
  <em>unspecified</em> bind(F&amp;&amp;, BoundArgs&amp;&amp;...);

namespace placeholders {
  // <em>M is the implementation-defined number of placeholders</em>
  extern <em>unspecified</em> _1;
  extern <em>unspecified</em> _2;
  .
  .
  .
  extern <em>unspecified</em> _M;

<ins>  template&lt;int N&gt;
  <em>unspecified</em> _at;

  template&lt;int N&gt;
  <em>unspecified</em> _from;

  template&lt;int N&gt;
  <em>unspecified</em> _to;

  template&lt;int B, int E&gt;
  <em>unspecified</em> _between;

  extern <em>unspecified</em> _all;</ins>
}
</pre>
</blockquote>

<p>Change the paragraph 20.10.9.1.2 Class template <code>is_placeholder</code> [func.bind.isplace].</p>

<blockquote class="std">
  <dl class="attribute">

    <dd><p><code>is_placeholder</code> can be used to detect the standard placeholders <ins><code>_all</code>, <code>_between&lt;B, E&gt;</code>, <code>_to&lt;N&gt;</code>, 
           <code>_from&lt;N&gt;</code>, <code>_at&lt;N&gt;</code>,</ins> <code>_1</code>, <code>_2</code>, and so on.
           <code>bind</code> uses <code>is_placeholder</code> to detect placeholders.</p></dd>

    <dd><p>Instantiations of the <code>is_placeholder</code> template shall meet the UnaryTypeTrait requirements (20.11.1).
           The implementation shall provide a definition that has the BaseCharacteristic of<del> <code>integral_constant&lt;int, J&gt;</code>
           if <code>T</code> is the type of <code>std::placeholders::_J</code>, otherwise it shall have a BaseCharacteristic of
           <code>integral_constant&lt;int, 0&gt;</code>.</del><ins>:</ins>
        </p><ins><ul>
           <li><code>integral_constant&lt;int, 1&gt;</code> if <code>T</code> is the type of <code>std::placeholders::_all</code>,</li>
           <li><code>integral_constant&lt;int, 1&gt;</code> if <code>T</code> is the type of <code>std::placeholders::_from&lt;N&gt;</code> and <code>N &gt; 0</code>,</li>
           <li><code>integral_constant&lt;int, 1&gt;</code> if <code>T</code> is the type of <code>std::placeholders::_to&lt;N&gt;</code> and <code>N &gt; 0</code>,</li>
           <li><code>integral_constant&lt;int, 1&gt;</code> if <code>T</code> is the type of <code>std::placeholders::_between&lt;B, E&gt;</code> and <code>B &gt; 0</code> and <code>E &gt;= B</code>,</li>
           <li><code>integral_constant&lt;int, J&gt;</code> if <code>T</code> is the type of <code>std::placeholders::_at&lt;J&gt;</code> or <code>std::placeholders::_J</code>,</li>
           <li><code>integral_constant&lt;int, 0&gt;</code> otherwise.</li>
        </ul></ins>
        <p>A program may specialize this template for a user-defined type <code>T</code> to
           have a BaseCharacteristic of <code>integral_constant&lt;int, N&gt;</code> with <code>N &gt; 0</code> to indicate that <code>T</code>
           should be treated as a placeholder type.</p></dd>
  </dl>
</blockquote>

<p>After paragraph 20.10.9.1.2 Class template <code>is_placeholder</code>, insert a new paragraph. (Paragraph 20.10.9.1.3 Function template <code>bind</code> [func.bind.bind] becomes 20.10.9.1.?)</p>
  
<blockquote class="stdins"> 
<h4>20.10.9.1.3 Class template <code>parameter_indexes</code> <span style="float:right">[func.bind.paramidx]</span></h4>

<pre>
namespace std {
  template&lt;class T, int N&gt; struct parameter_indexes; // see below
}</pre>

  <dl class="attribute">
    <dd><p><code>bind</code> uses <code>parameter_indexes</code> to determine indexes of parameters of the forwarding call wrapper
           to be forwarded to stored callable object as replacement for placeholder.</p></dd>

    <dd><p>The implementation shall provide a definition of <code>parameter_indexes&lt;T, N&gt;</code> that is publicly and unambiguously derived from:
    </p><ul>
      <li><code>integer_sequence&lt;int&gt;</code> 
          if <code>T</code> is the type of <code>std::placeholders::_all</code> and <code>N == 0</code>,</li>
      <li><code>integer_sequence&lt;int, 1, 2, ..., N&gt;</code> 
          if <code>T</code> is the type of <code>std::placeholders::_all</code> and <code>N &gt; 0</code>,</li>
      <li><code>integer_sequence&lt;int&gt;</code>
          if <code>T</code> is the type of <code>std::placeholders::_between&lt;B,B&gt;</code> and <code>N &gt;= B-1</code>,</li>
      <li><code>integer_sequence&lt;int, B, B+1, ..., E-1&gt;</code>
           if <code>T</code> is the type of <code>std::placeholders::_between&lt;B,E&gt;</code> and <code>B &lt; E</code> and <code>N &gt;= E-1</code>,</li>
      <li><code>integer_sequence&lt;int&gt;</code>
          if <code>T</code> is the type of <code>std::placeholders::_to&lt;1&gt;</code> and <code>N == 0</code>,</li>
      <li><code>integer_sequence&lt;int, 1, 2, ..., K-1&gt;</code>
          if <code>T</code> is the type of <code>std::placeholders::_to&lt;K&gt;</code> and <code>N &gt;= K-1</code>,</li>
      <li><code>integer_sequence&lt;int&gt;</code>
          if <code>T</code> is the type of <code>std::placeholders::_form&lt;K&gt;</code> and <code>N == K-1</code>,</li>
      <li><code>integer_sequence&lt;int, K, K+1, ..., N&gt;</code>
          if <code>T</code> is the type of <code>std::placeholders::_form&lt;K&gt;</code> and <code>N &gt;= K</code>,</li>
      <li><code>integer_sequence&lt;int, j&gt;</code>
          if <code>T</code> is not one of the types described in the previous items
          and the value <code>j</code> defined as <code>is_placeholder&lt;T&gt;::value</code> is not zero
          and <code>N &gt;= j</code>,</li>
    </ul><p></p></dd>

    <dd><p>A program may specialize or partially specialize <code>parameter_indexes</code> template for a user-defined placeholder type to be publicly and 
           unambiguously derived from <code>integer_sequence&lt;int, i1, i2, ..., iN&gt;</code> with values <code>i1, i2, ..., iN</code> greater than zero
           to indicate indexes of parameters of the forwarding call wrapper to be forwarded to stored callable object as replacement for placeholder.</p></dd>

    <dd><p>A program is ill-formed if it necessitates the instantiation of <code>parameter_indexes&lt;T, N&gt;</code> that does not satisfy criteria of any of the bullets in paragraph 1
           and does not match a specialization or a partial specialization of template <code>parameter_indexes</code> defined in the program.</p></dd>

  </dl>

</blockquote>

<p>Change the paragraph 20.10.9.1.3 Function template <code>bind</code> [func.bind.bind].</p>

<blockquote class="std">
<pre>
template&lt;class F, class... BoundArgs&gt;
  <em>unspecified</em> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</pre>

  <dl class="attribute">

    <dt>Requires:</dt>
    <dd><p><code>is_constructible&lt;FD, F&gt;::value</code> shall be true.
           For each <code>Ti</code> in <code>BoundArgs</code>, <code>is_constructible&lt;TiD, Ti&gt;::value</code> shall be true.
           <del><code>INVOKE (fd, w1, w2, ..., wN)</code> (20.10.2) shall be a valid expression for some values <code>w1, w2, ..., wN</code>, where <code>N == sizeof...(bound_args)</code>.</del>
           <ins><code>fd</code> shall be a callable object ([func.def] 20.10.1).</ins></p></dd>

    <dt>Returns:</dt>
    <dd><p>A forwarding call wrapper <code>g</code> with a weak result type (20.10.2).
           The effect of <code>g(u1, u2, ..., uM)</code> shall be 
           <del><code><em>INVOKE</em> (fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., std::forward&lt;VN&gt;(vN), 
                                           result_of&lt;FD <em>cv</em> &amp; (V1, V2, ..., VN)&gt;::type)</code></del>
           <ins><code><em>INVOKE</em> (fd, std::forward&lt;P1&gt;(p1)..., std::forward&lt;P2&gt;(p2)..., ..., std::forward&lt;PN&gt;(pN)...,
                                           result_of&lt;FD <em>cv</em> &amp; (P1..., P2..., ..., PN...)&gt;::type)</code></ins>
           , where <code><em>cv</em></code> represents the cv-qualifiers of <code>g</code> and the values and types of <del>the</del>
           <ins>elements of each of</ins> bound arguments <del><code>v1, v2, ..., vN</code></del> <ins>packs <code>p1, p2, ..., pN</code></ins>
           are determined as specified below.
           The copy constructor and move constructor of the forwarding call wrapper shall throw an exception if and only if the corresponding
           constructor of <code>FD</code> or of any of the types <code>TiD</code> throws an exception.
         </p></dd>

    <dt>Throws:</dt>
    <dd><p>Nothing unless the construction of <code>fd</code> or of one of the values <code>tid</code> throws an exception.</p></dd>

    <dt>Remarks:</dt>
    <dd><p>The return type shall satisfy the requirements of <code>MoveConstructible</code>.
           If all of <code>FD</code> and <code>TiD</code> satisfy the requirements of <code>CopyConstructible</code>,
           then the return type shall satisfy the requirements of <code>CopyConstructible</code>.
           [ <em>Note:</em> This implies that all of FD and TiD are MoveConstructible. <em>— end note</em> ]
     </p></dd>

  </dl>

<pre>
template&lt;class R, class F, class... BoundArgs&gt;
  <em>unspecified</em> bind(F&amp;&amp; f, BoundArgs&amp;&amp;... bound_args);
</pre>

  <dl class="attribute">

    <dt>Requires:</dt>
    <dd><p><code>is_constructible&lt;FD, F&gt;::value</code> shall be true.
           For each <code>Ti</code> in <code>BoundArgs</code>, <code>is_constructible&lt;TiD, Ti&gt;::value</code> shall be true.
           <del><code>INVOKE (fd, w1, w2, ..., wN)</code> (20.10.2) shall be a valid expression for some values <code>w1, w2, ..., wN</code>, where <code>N == sizeof...(bound_args)</code>.</del>
           <ins><code>fd</code> shall be a callable object ([func.def] 20.10.1).</ins></p></dd>

    <dt>Returns:</dt>
    <dd><p>A forwarding call wrapper <code>g</code> with a weak result type (20.10.2).
           The effect of <code>g(u1, u2, ..., uM)</code> shall be 
           <del><code><em>INVOKE</em> (fd, std::forward&lt;V1&gt;(v1), std::forward&lt;V2&gt;(v2), ..., std::forward&lt;VN&gt;(vN), R)</code></del>
           <ins><code><em>INVOKE</em> (fd, std::forward&lt;P1&gt;(p1)..., std::forward&lt;P2&gt;(p2)..., ..., std::forward&lt;PN&gt;(pN)..., R)</code></ins>
           , where <code><em>cv</em></code> represents the cv-qualifiers of <code>g</code> and the values and types of <del>the</del>
           <ins>elements of each of</ins> bound arguments <del><code>v1, v2, ..., vN</code></del> <ins>packs <code>p1, p2, ..., pN</code></ins>
           are determined as specified below.
           The copy constructor and move constructor of the forwarding call wrapper shall throw an exception if and only if the corresponding
           constructor of <code>FD</code> or of any of the types <code>TiD</code> throws an exception.
         </p></dd>

    <dt>Throws:</dt>
    <dd><p>Nothing unless the construction of <code>fd</code> or of one of the values <code>tid</code> throws an exception.</p></dd>

    <dt>Remarks:</dt>
    <dd><p>The return type shall satisfy the requirements of <code>MoveConstructible</code>.
           If all of <code>FD</code> and <code>TiD</code> satisfy the requirements of <code>CopyConstructible</code>,
           then the return type shall satisfy the requirements of <code>CopyConstructible</code>.
           [ <em>Note:</em> This implies that all of FD and TiD are MoveConstructible. <em>— end note</em> ]
     </p></dd>

   <dd><p>The values of <del>the</del><ins>elements of each</ins> <em>bound arguments</em> 
          <del><code>v1, v2, ..., vN</code></del> <ins><em>pack</em> <code>pi</code></ins>
          and their corresponding types <del><code>V1, V2, ..., VN</code></del> depend on the 
          type<del>s</del> <code>TiD</code> derived from the call to <code>bind</code>
          <ins>, number of parameter of the forwarding call wrapper <code>M = sizeof...(UnBoundArgs)</code></ins>
          and the cv-qualifiers <code>cv</code> of the call wrapper <code>g</code> as follows:
    </p>
    <ul>
      <li>if <code>TiD</code> is <code>reference_wrapper&lt;T&gt;</code>,
          <del>the argument is</del><ins>the pack contains single element with value</ins> <code>tid.get()</code>
          <del>and its type <code>Vi</code> is</del><ins>of type</ins> <code>T&amp;</code>;</li>
      <li>if the value of <code>is_bind_expression&lt;TiD&gt;::value</code> is true,
          <del>the argument is</del><ins>the pack contains single element with value</ins> <code>tid(std::forward&lt;Uj&gt;(uj)...)</code> 
          <del>and its type <code>Vi</code> is</del><ins>of type</ins> <code>result_of&lt;TiD <em>cv</em> &amp; (Uj&amp;&amp;...)&gt;::type&amp&amp</code>;</li>
      <li>if the value <code>j</code> of <code>is_placeholder&lt;TiD&gt;::value</code> is not zero
          <ins>and <code>parameter_indexes&lt;TiD, M&gt;</code> is derived from <code>integer_sequence&lt;int, j1, j2, ..., jK&gt;</code></ins>,
          <del>the argument is <code>std::forward&lt;Uj&gt;(uj)</code>  and its type <code>Vi</code> is <code>Uj&amp;&amp;</code></del>
          <ins>the pack contains <code>K</code> elements with values <code>std::forward&lt;Uj1&gt;(uj1), std::forward&lt;Uj2&gt;(uj2), ..., std::forward&lt;UjK&gt;(ujK)</code>
          of types <code>Uj1&amp;&amp;, Uj2&amp;&amp;, ..., UjK&amp;&amp;</code> respectively</ins>;</li>
      <li>otherwise, <del>the value is</del><ins>the pack contains single element with value</ins> <code>tid</code> 
          <del>and its type <code>Vi</code> is</del><ins>of type</ins> <code>TiD <em>cv</em> &amp;</code>.</li>
    </ul><p></p></dd>

  </dl>
</blockquote>

<p>Change the paragraph 20.10.9.1.4 Placeholders [func.bind.place].</p>

<blockquote class="std"> 
<pre>
namespace placeholders {
  // <em>M is the implementation-defined number of placeholders</em>
  extern <em>unspecified</em> _1;
  extern <em>unspecified</em> _2;
  .
  .
  .
  extern <em>unspecified</em> _M;

<ins>  template&lt;int N&gt;
  <em>unspecified</em> _at;

  template&lt;int N&gt;
  <em>unspecified</em> _from;

  template&lt;int N&gt;
  <em>unspecified</em> _to;

  template&lt;int B, int E&gt;
  <em>unspecified</em> _between;

  extern <em>unspecified</em> _all;</ins>
}
</pre>

  <dl class="attribute">

    <dd><p>All placeholder types shall be <code>DefaultConstructible</code> and <code>CopyConstructible</code>,
           and their default constructors and copy/move constructors shall not throw exceptions.
           It is implementation-defined whether placeholder types are <code>CopyAssignable</code>.
           <code>CopyAssignable</code> placeholders’ copy assignment operators shall not throw exceptions.</p></dd>

           <dd><p><ins>A program that necessitates the instantiation of <code>_at&lt;N&gt;</code>, <code>_from&lt;N&gt;</code> or <code>_to&lt;N&gt;</code> with <code>N &lt;= 0</code> is ill-formed.</ins></p></dd>
           
           <dd><p><ins>A program that necessitates the instantiation of <code>_between&lt;B, E&gt;</code> with <code>B &lt;= 0</code> or <code>E &lt;= 0</code> or <code>B &gt; E</code> is ill-formed.</ins></p></dd>

  </dl>

</blockquote>


<h2><a name='implementability'>Implementability</a></h2>

<p>Proposed change can be implemented as pure library extension in C++14. Implementation of <code>bind</code> function that conforms proposed wording can be found <a href="https://github.com/tomaszkam/proposals/tree/master/bind">https://github.com/tomaszkam/proposals/tree/master/bind</a>.</p>

<h2><a name="acknowledgements">Acknowledgements</a></h2>

<p>Jonathan Wakely originally proposed idea of multi parameter placeholders in discussion group <a href="https://groups.google.com/a/isocpp.org/forum/#!msg/std-proposals/CxpGVY1APcs/_RYAajMGhcUJ">ISO C++ Standard - Future Proposals</a>.</p>
<p>Andrzej Krzemieński offered many useful suggestions and corrections to the proposal.</p>


<h2><a name="appendix.bind_vs_lambda">Appendix: Why we need bind when we have a generic lambda?</a></h2>

<p>After introduction of generic lambda and extensions to the capture, some of the C++ community presented opinion
that <code>std::bind</code> is no longer necessary and should not be longer recommend or even become deprecated.
To validate such statement, we would need to prove that the lambda is as good as bind in every context, but to 
show that <code>bind</code> is still useful, we need to point out range of usage, when it behaves better.</p> 

<p>The author want to emphasise that the aim of this section is to present situation when <code>std::bind</code> leds
to more readable and less error prone code than a lambda. All examples presented this section do not aim to prove that bind
should be used instead of lambda in every context.</p>

<h3><a name="appendix.bind_vs_lambda.return">Specifying return type</a></h3>

<p>Default return type deduction for a lambda will preform return by value, which is optimal approach
is build-in is retruned, for example if we use lambda to write a predicate (function returning <code>bool</code>)
for STL algorithms, but it introduces performance overhead if return by reference should be used.</p>

<p>Lets assume that we want to write to transform a vector of <code>Employee</code> (<code>ve</code>) in to a vector
of full names.</p>
<pre>std::transform(std::begin(ve), std::end(ve), std::back_inserter(vfn),
               [](const Employee&amp; e) { return e.full_name(); });</pre>
<p>If the <code>full_name</code> function returns a <code>const std::string&amp;</code>, then above code will led to
two copies of the string being created for every element: one to return a value from the lambda and second to initialize
element in the vector (no move constructor will be used, because return type for a lambda preserve constness,
so <code>const std::string</code> will be deduced in this situation). To avoid above problems we may specify the return
type for a lambda.</p>
<pre>std::transform(std::begin(ve), std::end(ve), std::back_inserter(vfn),
               [](const Employee&amp; e) -> const auto&amp; { return e.full_name(); });</pre>
<p>Should approach will fix above problems, but if the function <code>full_name</code> would be changed to
return by value, then above code will cause dangling reference problem, but to avoid such problems we may use
the <code>decltype(auto)</code> deduction:
<pre>std::transform(std::begin(ve), std::end(ve), std::back_inserter(vfn),
               [](const Employee&amp; e) -> decltype(auto) { return e.full_name(); });</pre>

<p>I we attempt to repeat the same exercise using standard function wrappers, none of above problems will be present and
in addition it will benefit from single syntax for handling method pointers and member pointers.<p>
<pre>std::transform(std::begin(ve), std::end(ve), std::back_inserter(vfn),
               std::mem_fn(&amp;Employee::full_name));</pre>

<h3><a name="appendix.bind_vs_lambda.capturing">Capturing variables</a></h3>

<p>In most common case when the closure does not outlive the context in which it was created and is invoked in the same
thread of the execution, like when it is passed to STL algorithm, it is safe and optimal to use capture all be reference
(<code>[&amp;]</code>) semantics.
For the situation when we want to pass closure, probably wrapped into <code>std::function</code>, outside the current context,
then it is save to use capture all by value (<code>[=]</code>), if we assume that we do not use any unmanaged pointer inside
it, but if we want to pass our function to other thread of execution we need to be sure that will are not causing data races,
data my occur is some handler with shallow copy semantics is captured by a lambda (e.g. <code>std::shared_ptr</code>).

<p>Above reasoning led us to conclusion that when lambda is passed outside current context (to other thread of by retruning
it) it is safer to explicit my specify the variables that should be captured. For example, given bellow definitions:</p>
<pre>struct Widget { void process(std::string&gt;) const; };
std::unqiue_ptr&lt;Widget&gt; createConcreteWidget();
std::vectorlt&;tstd::string&gt; vs;</pre>

<p>We want to create callback that will process first element of the vector using given callback. Our first attempt would be to write:</p>
<pre>[&amp;vs] { createConcreteWidget()-&gt;process(vs[0]); }</pre>

<p>We have additionally postponed creation of <code>Widget</code> until the point when lambda is invoked and if the lambda
is passed outside current context, we loss control of the point of widget creation. To fix above problem we try to create widget
and capture it from local context:</p> 
<pre>auto widget = createConcreteWidget();
[&amp;vs, widget] { widget-&gt;process(vs[0]); }</pre>

<p>Above code will not compile because we want to copy a move-only type <code>std::unique_ptr&lt;Widget&gt;</code>. 
In addition find that we are capturing whole vector <code>vs</code>, although we are using only one of the element. 
Both of this issues may be fixed using a C++14 extended lambda capture syntax:</p>
<pre>[&amp;elem = vs.front(), widget = createConcreteWidget()] { widget-&gt;process(elem); }</pre>

<p>Our task can be reduced to binding two parameters to a function and standard already provides a component designed
for such purpose, named <code>std::bind</code>:</p>
<pre>std::bind(&amp;Widget::process, createConcreteWidget(), std::ref(vs.front()))</pre>

<p>In connection to a problem with a <code>Widget</code> creation, it is worth noticing that sometimes it is recommend
to capture some precomputed values in lambda. Lets return we want to find a <code>Employee</code> with given first and
last name:</p>
<pre>std::find_if(std::begin(ve), std::end(ve), [](const auto&amp; e) { return e.full_name() == first + ' ' + last; });</pre>

<p>This innocent looking code has a performance issue inside it: the string <code>first + ' ' + last</code> is constant for every element,
but new instance is create for every iterator. To avoid such problems we should capture such value:</p>
<pre>std::find_if(std::begin(ve), std::end(ve), [name = first + " " + last](const auto&amp; e) { return e.full_name() == name; });</pre>

<p>Although use of <code>std::bind</code> will eliminate the problem, the author would recommend use of lambda is such case, because
use of nested <code>std::bind</code> is necessary in this situation:</p>
<pre>std::find_if(std::begin(ve), std::end(ve), std::bind(std::equal_to&lt;&gt;, std::bind(&amp;Employee::full_name, _1), first + ' ' + last));</pre>

<h2><a name="literature">References</a></h2>

<ol>
  <li>Mikhail Semenov, "Introducing an optional parameter for mem_fn, which allows to bind an object to its member function" (N3702, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3702.htm">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3702.htm</a>)</li>
  <li>Tomasz Kamiński, Implementation of bind function (<a href="https://github.com/tomaszkam/proposals/tree/master/bind">https://github.com/tomaszkam/proposals/tree/master/bind</a>)</li>
</ol>

</body></html>
