<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style type="text/css">
pre {margin-left:20pt; }
pre > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
pre > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none; 
  padding-right: 0.4em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none;
  padding-right: 0.4em; border: none; }
</style>

<title>Extend INVOKE to support types convertible to target class</title>
<script type="text/javascript">$(function() {
    var next_id = 0
    function find_id(node) {
        // Look down the first children of 'node' until we find one
        // with an id. If we don't find one, give 'node' an id and
        // return that.
        var cur = node[0];
        while (cur) {
            if (cur.id) return curid;
            if (cur.tagName == 'A' && cur.name)
                return cur.name;
            cur = cur.firstChild;
        };
        // No id.
        node.attr('id', 'gensection-' + next_id++);
        return node.attr('id');
    };

    // Put a table of contents in the #toc nav.

    // This is a list of <ol> elements, where toc[N] is the list for
    // the current sequence of <h(N+2)> tags. When a header of an
    // existing level is encountered, all higher levels are popped,
    // and an <li> is appended to the level
    var toc = [$("<ol/>")];
    $(':header').not('h1').each(function() {
        var header = $(this);
        // For each <hN> tag, add a link to the toc at the appropriate
        // level.  When toc is one element too short, start a new list
        var levels = {H2: 0, H3: 1, H4: 2, H5: 3, H6: 4};
        var level = levels[this.tagName];
        if (typeof level == 'undefined') {
            throw 'Unexpected tag: ' + this.tagName;
        }
        // Truncate to the new level.
        toc.splice(level + 1, toc.length);
        if (toc.length < level) {
            // Omit TOC entries for skipped header levels.
            return;
        }
        if (toc.length == level) {
            // Add a <ol> to the previous level's last <li> and push
            // it into the array.
            var ol = $('<ol/>')
            toc[toc.length - 1].children().last().append(ol);
            toc.push(ol);
        }
        var header_text = header.text();
        toc[toc.length - 1].append(
            $('<li/>').append($('<a href="#' + find_id(header) + '"/>')
                              .text(header_text)));
    });
    $('#toc').append(toc[0]);
})
</script>
</head>

<body>

<h1><a name="title">Extend INVOKE to support types convertible to target class</a></h1>


<!--p>ISO/IEC JTC1 SC22 WG21 N????</p--> 
<p>2013-05-27</p>

<address>
Tomasz Kamiński, tomaszkam@gmail.com
</address>


<h2><a name="intro">Introduction</a></h2>

<p>This proposal is to extend the definition of <code>INOVKE</code> for class member pointers to cover types convertible to a target class of the pointer, like <code>std::reference_wrapper</code>.</p>

<p>Proposal also resolves <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2219">LWG issue #2219</a></p>

<!--h2><a name="toc">Table of contents</a></h2-->

<h2><a name="motivation">Motivation and Scope</a></h2>

<p>The standard <code>INOVKE</code> expression models the member pointers as pair of free standing functions, that takes a reference and the pointer (including smart pointers) to target class respectively. However there is difference in semnatics between the <code>INVOKE</code> expression for member pointers and functors - for member pointers the conversions are not taken into consideration in matching first agument.</p>

<p>This behavior difference prohibit usage of wrapper types (ex. <code>std::reference_wrapper</code>, <code>boost::flyweight</code>) with the standard library functions that are modeled using <code>INVOKE</code> (ex. <code>std::bind</code>, <code>std::mem_fn</code>, <code>std::async</code>). The aim of this proposal is fix that usablity problem via extending defintion of <code>INVOKE</code> to allow conversions.</p>

<p>Proposed change will also cover cases of set of convertible types that models the same logical entity (ex .std::chrono::duration specializations). With the acceptance of this proposal, the <code>std::bind(&std::chrono<double>::count, _1)</code> will create functor returning amount of seconds for any specialization of std::chrono::duration.</p>

<h3><a name="motivation.deference-operator">Defining <code>operator*</code></a></h3>

<p>The well know workaround for this problem, is to define the <code>operator*</code> that will return the result as the conversion operator. Firstly this solution is only aplicable for situation where the interface of the class can be changed, so it is not feasible for third-party librarby objects. Secondly it leads to unelengant interface than combines wrapper and pointer semantics.</p>

<h3><a name="motivation.lambda">Using lambda</a></h3>

<p>The other workaround of this problem is to use the lambda expression instead of library functions, but in the most examples it leads to the less readable and clear code. Please compare following code snippets:</p>
<pre>
  std::bind([]foo, _1, expr, ref(a));
  [e = expr, &a] (auto&& arg) -> decltype(auto) { return foo(_1, e, std::forwrad<delctype(arg)>(arg)); }
</pre>

<h3><a name="motivation.bind-cast">Define special cast functor</a></h3>

<p>In case of <code>bind</code> expressions the problem may be mitigated by introduction of additional cast functor and preforms required casting.</p>
<pre>
std::bind(&Class::method, _1)(std::ref(clazz));
std::bind(&Class::method, cast&lt;Class&amp;&gt;(_1))(std::ref(clazz));
</pre>
<p>However this approach cannot be used in combination with other library components that depends of <code>INOVKE</code> (ex. <code>std::async</code>, <code>std::call_once</code>).</p>

<h2><a name="design">Design Decisions</a></h2>

<h3><a name="design.specializations">Threatment of ambigus classes</a></h3>

<p>Extending the defintion of the <code>INOVKE</code> to support of the convertible operators may lead to the ambiguity with objects <code>t</code>, for which both result of expression <code>t</code> and <code>*t</code> are covertible to target class. Example:
<pre>
  struct Clazz { int foo; }

  struct Mixed
  {
    Clazz& operator*();
    operator Clazz&();
  };
</pre>
In case of such amibiguity the expression <code>INVOKE(&Clazz::foo, Mixed{})</code> may be interpreted as <code>static_cast&lt;Clazz&amp;&gt;(Mixed{}).*foo</code> or
<code>(*Mixed{}).*foo</code>.
</p>

<p>The described ambiguity may be sloved by:
  <ul>
    <li>Option 1: compilation error</li>
    <li>Option 2: prefer <code>operator*</code></li>
    <li>Option 3: prefer conversion</li>
  </ul>
</p>

<h3><a name="design.error">Option 1: compilation error</a></h3>

<p>This option seems to be most intuitive to the author of the proposal and it leads to the less complicated defintion of the <code>Mixed</code>. The major problem ot this solution is that it would break existing standard compilant code in case of <code>Mixed</code> class, which may be the result of implementing one of the current <a href="#motivation.deference-operator">work arounds</a> to the problem.</p>

<p>Wording for this option is presented in the alternate proposal section.</p>

<h3><a name="design.prefer-dereference">Option 2: prefer <code>operator*</code></h3>

<p>This option is not breaking approach and was considered as the best resultion by the majority of participtians of dicussion on <a href="https://groups.google.com/a/isocpp.org/forum/?fromgroups#!topic/std-proposals/FtilAt9V_1c">ISO C++ Standard - Future Proposals</a> forum. The only drawback is this options is that it leads to more complicated defintion of <code>INVOKE</code>.</p>

<p>This proposal recomends to implemented this options.</p>

<h3><a name="design.specializations">Option 3: prefer conversion</a></h3>

<p>This approach will make the <code>INVOKE</code> in case of member pointer most consistent with the free-standing function, but it will introduce the silent behaviour chnages in case of classes similiar to <code>Mixed</code> example, so it is not futher discussed.</p>



<h2><a name="standard">Impact On The Standard</a></h2>

<p>This proposal has no dependencies beyond a C++11 compiler and 
Standard Library implementation. (It depends on perfect forwarding, <code>decltype</code> and trailing return types.)</p>

<p>Nothing depends on this proposal.</p>

<h2><a name="wording">Proposed wording</a></h2>

<p>Change the paragraph 20.10.2 Requiremenets [func.require].</p>
  
<blockquote class="std">
  <dl class="attribute">
     
    <dd><p>Viable reference types <code>TR</code> for member pointer <code>p</code> of type <code>M T::*</code> are:
    </p><ul>
      <li><code>T cv&amp;</code>, <code>T cv&amp;&amp;</code> for all posible cv-qualifiers <code>cv</code> if <code>M</code> is not function type,</li>
      <li><code>T cv&amp;</code>, <code>T cv&amp;&amp;</code> if <code>M</code> is function type without ref-qualifier and with cv-qualifiers <code>cv</code>,</li>
      <li><code>T cv ref</code> if <code>M</code> is function type without ref-qualifier <code>ref</code> and cv-qualifiers <code>cv</code>.</li>
    </ul><p></p></dd>

    <dd><p>Define <code>INVOKE(f, t1, t2, ..., tN)</code> as follows:
    </p><ul>
      <li>when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>TR</code> is viable reference type for <code>f</code>:
        <ul>
          <li><code>(t1.*f)(t2, ..., tN)</code> when <code>t1</code> is an object of type <code>T</code> or a reference to an object of type <code>T</code> or a reference to an object of a type derived from <code>T</code>;</li>
          <li><code>(static_cast&lt;TR&gt;(*t1).*f)(t2, ..., tN)</code> when <code>t1</code> does not match criteria of any of previous point and <code>*t1</code> is implicitly convertible to <code>TR</code>;</li>
          <li><code>(static_cast&lt;TR&gt;(t1).*f)(t2, ..., tN)</code> when <code>t1</code> does not match criteria of any of previous point and <code>t1</code> is implicitly convertible to <code>TR</code>;</li>
        </ul>
      </li>
      <li>when <code>f</code> is a pointer to member data of a class <code>T</code> and <code>N == 1</code> and <code>TR</code> is viable reference type for <code>f</code>:
        <ul>
          <li><code>t1.*f</code> when <code>t1</code> is an object of type <code>T</code> or a reference to an object of type <code>T</code> or a reference to an object of a type derived from <code>T</code>;</li>
          <li><code>static_cast&lt;TR&gt;(*t1).*f</code> when <code>t1</code> does not match criteria of any of previous point and <code>*t1</code> is implicitly convertible to <code>TR</code>;</li>
          <li><code>static_cast&lt;TR&gt;(t1).*f</code> when <code>t1</code> does not match criteria of any of previous point and <code>t1</code> is implicitly convertible to <code>TR</code>;</li>
        </ul>
      </li>
      <li><code>f(t1, t2, ..., tN)</code> in all other cases.
    <ul><p></p></dd>

  </dl>
</blockquote>

<h2><a name="acknowledgements">Acknowledgements</a></h2>

<!--p>Mateusz Kwiatkowski, Jonathan Wakely and Daniel Krügler offered many useful suggestions and corrections to the proposal.</p-->

<h2><a name="literature">References</a></h2>

<ol>

<li>Stephan T. Lavavej, "Making Operator Functors greater&lt;&gt;" (N3421, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm</a>)</li>

<li>Faisal Vali, Herb Sutter, Dave Abrahams, "Generic (Polymorphic) Lambda Expressions (Revision 3) " (<a href="https://github.com/akrzemi1/Optional/">https://github.com/akrzemi1/Optional/</a>)</li>
</ol>


</body></html>