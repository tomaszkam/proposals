<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style type="text/css">
pre {margin-left:20pt; }
pre > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > i {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
pre > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
code > em {
  font-family: "OCR A Extended", "Consolas", "Lucida Console", monospace;
  font-style:italic;
}
body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table.header { border: 0px; border-spacing: 0;
  margin-left: 0px; font-style: normal; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none; 
  padding-right: 0.4em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.4em; border: none;
  padding-right: 0.4em; border: none; }
</style>

<title>Fixing 'Relation's</title>
</head>

<body>

<table class="header"><tbody>
  <tr>
    <th>Document number:&nbsp;&nbsp;</th><th> </th><td>DXXXXR0</td>
  </tr>
  <tr>
    <th>Date:&nbsp;&nbsp;</th><th> </th><td>2018-01-31</td>
  </tr>
  <tr>
    <th>Project:&nbsp;&nbsp;</th><th> </th><td>Programming Language C++, Library Evolution Working Group and Evolution Working Group</td>
  </tr>
  <tr>
    <th>Reply-to:&nbsp;&nbsp;</th><th> </th><td><address>Tomasz Kamiński &lt;tomaszkam at gmail dot com&gt;</address></td>
  </tr>
</tbody></table>

<h1><a name="title">Fixing <code>Relation</code>s</a></h1>

<h2><a name="intro">1. Introduction</a></h2>

<p>This paper proposes changing the <code>Relation</code> and related concepts, to achieve following goals:</p>
<ul>
  <li><em>zero overhead</em>: uses of range version of standard algorithm shall not be less effective than hand written code,
                              especially it cannot be less effective than STL1 counterparts,</li>
  <li><em>generality</em>: concepts should be usable both in case of algorithms and containers, they should map to the underlying 
                           mathematically concept and avoid imposing additional requirement,</li>
  <li><em>soundness</em>: the syntactic requirements of the algorithm should allow (runtime) check if supplied object satisfies
                           associated semantic requirement.</li>
</ul>
<p>The secondary goal is to simplify migration to the rangified version of algorithms, however reaching of this goal should 
   not undermine above properties.</p>

<p>This paper argues that the currently specified concept does not achieve above goal, due the additional requirement of <code>CommonReference</code>
   for types of parameters. As consequence we propose to relax this concept (and all derived concepts) by removing above requirement.</p>

<!--h2><a name="toc">Table of contents</a></h2-->

<h2><a name="history">2. Revision history</a></h2>

<h3><a name="history.r0">2.1. Revision 0</a></h3>

<p>Initial revision.</p>

<h2><a name="motivation">3. Motivation and Scope</a></h2>

<p>Family of the standard algorithms related to sorting and operations on sorted sequence (<code>sort</code>, <code>lower_bound</code>, <code>set_intersection</code>, ...)
   are accepting an functor, that is representing a <em>weak ordering</em>. Examples of such ordering, includes relation resulting from a composition of the <em>key function</em>
   that extracts certain part of the object, and the <em>strong ordering</em> relation over extract part.</p>
   
<p>To illustrate lets us consider following <code>NameLess</code> functor, that is comparing object of <code>Employee</code> by
   comparing only <code>name</code> member:</p>
<pre>struct NameLess
{
   bool operator()(Employee const&amp; lhs, Employee const&amp; rhs) const
   { return lhs.name &lt; lhs.name; }

   bool operator()(Employee const&amp; lhs, std::string_view rhs) const
   { return lhs.name &lt; rhs; }

   bool operator()(std::string_view lhs, Employee const&amp; rhs) const
   { return lhs &lt; lhs.name; }
};</pre> 

<p>Having above functor, we may sort a vector <code>ve</code> of the <code>Employee</code> object by name:</p>
<pre>std::sort(ve.begin(), ve.end(), NameLess{});</pre>
<p>Now that code can be upgrade to use Ranges:</p>
<pre>std::ranges::sort(ve.begin(), ve.end(), NameLess{});
std::ranges::sort(ve, NameLess{});</pre>
<p>Finally we have an option to provide our <em>key function</em> and <em>strong ordering</em> separately:</p>
<pre>std::ranges::sort(ve, std::less&lt;&gt;{}, &amp;Employee::name);</pre>

<p>Once the vector is sorted, we can use one of the other algorithms to find all employee's with given name
   (i.e. find <em>equivalence class</em> for given value):</p>
<pre>std::equal_range(ve.begin(), ve.end(), "Kowalski"s, NameLess{});</pre>
<p>However, if I want to migrate the above code to Ranges, by stating:</p>
<pre>std::ranges::equal_range(ve.begin(), ve.end(), "Kowalski"s, NameLess{});
std::ranges::equal_range(ve, "Kowalski"s, NameLess{});</pre>
<p>The above invocations will not compile, and I will be forced to rewrite my functor into separate
   projection and comparision:</p>
<pre>std::ranges::equal_range(ve, "Kowalski"s, std::less&lt;&gt;{}, &amp;Employee::name);</pre>

<p>The above compilation problem is caused by the fact that for the relation to satisfy <code>StrictWeakOrdering&lt;NameLess, Employee, std::string&gt;</code>,
   such functor needs to satisfy <code>Relation&lt;NameLess, Employee, std::string&gt;</code>, which requires that the types <code>Employee</code> and 
   <code>std::string</code> has a common reference (<code>CommonReference&lt;Employee, std::string&gt;</code>).</p>

<p>In situation when <em>weak ordering</em> is defined in terms of the composition of the <em>key function</em> and <em>strong ordering</em>, the type
   returned by <em>key function</em> may be unrelated to the actual object type, as we are usually returning an member of that object. This means
   that the user is forced to rewrite they comparators into separate projection and homogeneous functor.</p>

<p>Note that we are placing this limitation inconstantly - in case of the sorting of the <code>Employee</code> object, the user may decide
   to merge the projection into the functor (<code>NameLess</code>), or provide it separately (combination of the <code>std::less&lt;&gt;{}, &amp;Employee::name</code>).
   While in case of the function searching for given key value, we are forced to separate projection on ordering into separate objects. 
   This puts an arbitrary limitation on the implementation freedom, and have negative consequences both on runtime performance of the code
   and its readability.</p>

<h3><a name="motivation.cost">3.1. Inefficient abstractions</a></h3>

<p>To illustrate the effect of above implementation, lets us consider the following problem: We have a <code>vector&lt;Itinerary&gt;</code>
   representing round-trip flights (to specific destination and back), and we want to extract find ones that are having departures
   on specific dates.</p>

<p>Firstly we defined the required comparators, <code>LegDepartureDateLess</code> compares departure date on leg, while <code>ItneraryDepartureDatesLess</code>
   compares departures of all legs:</p>
<pre>struct LegDepartureDateLess
{
   bool operator()(Leg const&amp; lhs, Leg const&amp; rhs) const
   { return lhs.departureDate &lt; rhs.departureDate; }

   bool operator()(Leg const&amp; lhs, std::chrono::local_days const&amp; rhs) const
   { return lhs.departureDate &lt; rhs; }

   bool operator()(std::chrono::local_days const&amp; lhs, Leg const&amp; rhs) const
   { return lhs &lt; rhs.departureDate; }
};

struct ItineraryDepartureDatesLess
{
  bool operator()(Itinerary const&amp; lhs, Itinerary const&amp; rhs) const
  { return less_impl(lhs.legs, rhs.legs); }

  bool operator()(std::vector&lt;std::chrono::local_days&gt; const&amp; lhs, Itinerary const&amp; rhs) const
  { return less_impl(lhs, rhs.legs); }

  bool operator()(Itinerary const&amp; rhs, std::vector&lt;std::chrono::local_days&gt; const&amp; lhs) const
  { return less_impl(lhs, rhs.legs); }
   
private:
  template&lt;typename Sequence1, typename Sequence2&gt;
  bool less_impl(Sequence1 const&amp; lhs, Sequence2 const&amp; rhs) const
  {
    return std::lexicographical_compare(lhs.begin(), lhs.end(),
                                        rhs.begin(), rhs.end(),
                                        LegDepartureDateLess{});
  }
};</pre>

<p>Given above comparison functions, we can sort the vector <code>vi</code> of <code>Itinerary</code>:</p>
<pre>std::sort(vi.begin(), vi.end(), ItineraryDepartureDatesLess{});</pre>
<p>After that we can search for specific set of departure dates (given as vector <code>vd</code>) in the logarithmic time:</p>
<pre>std::equal_range(vi.begin(), vi.end(), vd, ItineraryDepartureDatesLess{});</pre>

<p>If we want to implement the same functionality using the ranges, we can mechanically transform the code sorting elements:</p>
<pre>std::ranges::sort(vi, ItineraryDepartureDatesLess{});</pre>
<p>However such manual transformation will not work for searching of element:</p>
<pre>std::equal_range(vi, ItineraryDepartureDatesLess{});</pre>
<p>will not compile, as (unsuprisingly) there is no common reference between the <code>Itinerary</code> and <code>std::vector&lt;std::chrono::local_days&gt;</code>.</p>

<p>To fix above code, we need to represent split our comparator into separate projection and relation. In the first attempt we may define projection as follows:</p>
<pre>auto const toDepartureDates = [](Itinerary const&amp; i) -&gt; std::vector&lt;std::chrono::local_days&gt;
{ 
   std::vector&lt;std::chrono::local_days&gt; result(i.legs.size());
   std::ranges::transform(i.legs, result.begin(), &amp;Leg::departureDate);
   return result;
}</pre>

<p>For the comparator, we just need to invoke <code>lexicographical_compare</code> giving our following code:</p>
<pre>std::equal_range(vi, vd,
                 [](auto const&amp; lhs, auto const&amp; rhs) { return std::ranges::lexicographical_compare(lhs, rhs); },
                 toDepartureDates);</pre>
<p>The above code has a major drawback - for each comparison of elements (that is limited by O(n log n)) a temporary vector is created, leading
   to degradation of the code performance comparing to STL1 example.</p>

<p>This problem can be mitigated by returning a transform view from the <code>toDepartureDates</code> function, to reduce
   the cost of temporary production. However such view are not currently part of the Ranges, so it is not certain that
   they could be used to mitigate the problem. Furthermore, this still does not guarantee that the code will have same performance
   as corresponding STL1 version - to achieve that heroic implementation on the compiler side are required. 
   This is acknowledged  by range library author in <a href="http://ericniebler.com/2014/04/27/range-comprehensions/">"Performance" section of following post</a>.</p>

<p>As presented in above requirements, the implementation options limitation imposed by requiring an <code>CommonReference</code>
   for orderings, is negatively impacting the performance in the resulting code. This is true even for potential future extension
   to introduce view - user would be require to really on optimization to achieve same performance.
   In authors opinion, this means that current design of Ranges are breaking zero-overhead principle, that is backbone of
   C++ language - the user is able the implement same functionality in more efficient manner, by simply using older version
   of algorithms, that was not imposing such limitation.</p>

<h3><a name="motivation.sound">3.2. Mathematically (un)sound</a></h3>

<p>One of the arguments for the introduction of the  <code>CommonReference</code> requirement, is that it makes heterogeneous
   ordering mathematically sound. The definition of soundness is a bit subjective, but to counteract the argument, the author
   proposes following approach: The concept is considered to be sound, if it:
   <ul>
     <li>semantic requirements matches semantic requirements of the underlying mathematical definition,</li>
     <li>syntactic requirements allow above semantic requirement to be verified in code (if necessary at runtime).</li>
   </ul>
</p>

<p>In our case we are interested in the definition of the <em>weak ordering</em> over some domain <em>X</em>. The mathematical
   definition of <em>weak ordering</em> requires following axioms to be true:
   <ul>
     <li><em>irreflexivity</em>: for all <code>t</code> in <em>X</em>: <code>!r(t, t)</code></li>
     <li><em>asymmetry</em>: for all <code>t</code>, <code>u</code> in <em>X</em>: <code>r(t, u)</code> =&gt; <code>!r(u, t)</code></li>
     <li><em>transitivity</em>: for all <code>t</code>, <code>u</code>, <code>z</code> in <em>X</em>: <code>r(t, u) &amp;&amp; r(u, z)</code> =&gt; <code>r(t, z)</code></li>
     <li><em>transitivity of incomparability</em>: for all <code>t</code>, <code>u</code>, <code>z</code> in <em>X</em>: <code>(!r(t, u) &amp;&amp; !r(u,t)) &amp;&amp; (!r(u, z) &amp;&amp; !r(z, u))</code> =&gt; <code>(!r(t, z) &amp;&amp; !r(z, t))</code></li>
   </ul>
</p>

<p>The last requirement is necessary to show that the function <code>eq(x, y)</code> equivalent to <code>!r(x, y) &amp;&amp; !r(x, y)</code> is an equivalence relation,
    i.e. the relation is <em>reflexive</em> (guaranteed by <em>irreflexivity</em> of <code>r</code>),  <em>symmetric</em> (from definition), and <em>transitive</em> (imposed 
   directly by <em>transitivity of incomparability</em> for <code>r</code>). 
   This guarantee that for any <code>t</code>, <code>u</code> in the <em>X</em> only one of following is true:  <code>r(x, y)</code>,  <code>eq(x, y)</code>, <code>r(y, x)</code>,i
    where <code>eq</code> is equality relation. 
   That means that <code>r</code> also satisfies definition of <em>weak ordering</em> presented in section "4.2 Total and Weak Orderings" of "Elements of Programming" by Alexander Stepanov and Paul McJones.</p>

<p>To verify if given functor <code>f</code> is strict weak ordering over an domain consisting of object of type <code>T</code> (<code>Employee</code>) and
   of type <code>U</code> (note that domain is just set of elements, which may be on different type), we will require following invocation to be well-formed:
   <code>f(t, u)</code>, <code>f(u, t)</code>, <code>f(t, t)</code>, <code>f(u, u)</code>, where <code>t</code> is object of type <code>T</code> and <code>u</code>
   of type <code>U</code>.</p>

<p>In summary, neither the semantic requirement of the <em>weak ordering</em> nor the syntactic requirement imposed by them require existence 
   of the common reference (common type) for the objects in the domain.
   Furthermore introduction of this requirement is limiting the generating of the underlying algorithms (as can work with any <em>weak ordering</em>) which
   is step against ideas of generic programming.</p> 

<h3><a name="motivation.set">3.3. Tailored for algorithms</a></h3>

<p>The current definition of the <code>StrictWeakOrdering</code>, was coined in the context of its usage with newly proposed
   range version of standard algorithms, that accept separate relation and projection arguments. 
   This reasoning, misses other standard library components, that also accepts the comparators. This is especially important
   in case of ordered containers (<code>set</code>, <code>map</code>) that are accepting an <em>weak ordering</em> as comparator,
   and was recently expanded with heterogeneous lookup (<code>is_transparent</code> nested typename).</p>

<p>To illustrate, lets us consider following example, we want to have mapping from the employee's name to the full object, the easiest
   approach would be to use following map:</p>
<pre>std::map&lt;std::string, Employee&gt; nameMap;</pre>
<p>The drawback of above solution is that the name of the employee is held twice in the structure, once as the key, and once inside the
   object. To mitigate the problem, we could construct an <code>set</code> of <code>Employee</code> that compares only its name, i.e.</p>
<pre>std::set&lt;Employee, NameLess&gt; nameSet;</pre> 
<p>In addition we can allow queering <code>nameSet</code> by the actual names, by adding <code>is_transparent</code> nested typedef
   to the <code>NameLess</code> comparator. This solution esentially removes the value duplication.</p>

<p>Note that if the set definition would be changed, so the provided comparator is required to satisfy <code>StrictWeakOrdering</code>
   the code will no longer compile due the <code>CommonReference</code> requirement - this is same situation as in case of
   <code>equal_range</code> example presented in first paragraph.
   As consequence, constraining the ordered containers with current <code>StrictWeakOrdering</code> concept, will de-facto
   remove functionality of heterogeneous lookup from ordered associative containers.</p> 

<h2><a name="design">4. Design Decisions</a></h2>

<p>why require f(t,t)</p>
<p>no changes to totally ordered - outside of scope of paper</p>

<h2><a name="wording">5. Proposed Wording</a></h2>

<p>The proposed wording changes refer to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf">N4713</a> (C++ Working Draft, 2017-11-27).</p>


<h3><a name="motivation.core">5.1. Core wording</h3>

<p>Change in [over.match.oper] Operators in expressions paragraph 6 as follows:</p>
<blockquote class="std">
  <dl clas="attribute">
     <dd>The set of candidate functions for overload resolution for some operator <code>@</code>
         is the union of the member candidates, the non-member candidates, and the built-in candidates 
         for that operator <code>@</code>.
         If that operator is a relational ([exp.rel])<del> or</del><ins>,</ins> equality ([expr.eq])<ins>,
         or three-way comparison ([expr.spaceship])</ins> operator with operands x and y, 
         then for each member, non-member, or built-in candidate for the operator <code>&lt;=&gt;</code>:
         <ul>
           <li>that operator is added to the set of candidate functions for overload resolution if 
               <ins><code>@</code> is not <code>&lt;=&gt;</code> and</ins> <code><ins>(</ins>x &lt;=&gt; y<ins>)</ins> @ 0</code> is well-formed using that <code>operator&lt;=&gt;</code>; and</li>
           <li>a synthesized candidate is added to the candidate set where the order of the two parameters is reversed if
               <code>0 @ <ins>(</ins>y &lt;=&gt; x<ins>)</ins></code> is well-formed using that <code>operator&lt;=&gt;</code>;
        </ul>
        where in each case<ins>,</ins>
        <ul>
           <li><ins>if <code>@</code> is not <code>&lt;=&gt;</code>,</ins> <code>operator&lt;=&gt;</code> candidates are not considered for the recursive lookup of operator <code>@</code> <ins>and</ins></li>
           <li><ins>synthesized <code>operator&lt;=&gt;</code> candidates are not considered for the recursive lookup of operator <code>&lt;=&gt;</code></ins>.</li>
        </ul>
    </dd>
  </dl>
</blockquote>


<p>Change in [over.match.oper] Operators in expressions paragraph 8 as follows:</p>
<blockquote class="std">
  <dl clas="attribute">
     <dd>If an <code>operator&lt;=&gt;</code> candidate is selected by overload resolution for an operator <code>@</code>,
         <del>but <code>@</code> is not <code>&lt;=&gt;</code>,</del>
         <code>x @ y</code> is interpreted as <code>0 @ <ins>(</ins>y &lt;=&gt; x<ins>)</ins></code> if
         the selected candidate is a synthesized candidate with reversed order of parameters,
         or <code><ins>(</ins>x &lt;=&gt; y<ins>)</ins> @ 0</code> <del>otherwise</del><ins>if <code>@</code> is not <code>&lt;=&gt;</code></ins>,
         using the selected <code>operator&lt;=&gt;</code> candidate.</dd>
  </dl>
</blockquote>


<h3><a name="motivation.library">5.2. Library wording</h3>

<p>Add the following declarations at the end of the definition of the class <code></code> in [cmp.weakeq] Class <code>weak_equality</code> section.</p>
<blockquote class="stdins"> 
<pre>friend constexpr weak_equality operator&lt;=&gt;(weak_equality v, unspecified) noexcept;
friend constexpr weak_equality operator&lt;=&gt;(unspecified, weak_equality v) noexcept;</pre>
</blockquote>

<p>Insert the following at the end of [cmp.weakeq] Class <code>weak_equality</code> section.</p>
<blockquote class="stdins">
  <pre>constexpr weak_equality operator&lt;=&gt;(weak_equality v, unspecified) noexcept;
constexpr weak_equality operator&lt;=&gt;(unspecified, weak_equality v) noexcept;</pre>
  
  <dl class="attribute">
    <dt>Returns:</dt>
    <dd><code>v</code></dd>
  </dl>
</blockquote>

<p>Add the following declarations at the end of the definition of the class <code></code> in [cmp.strongeq] Class <code>strong_equality</code> section.</p>
<blockquote class="stdins"> 
<pre>friend constexpr strong_equality operator&lt;=&gt;(strong_equality v, unspecified) noexcept;
friend constexpr strong_equality operator&lt;=&gt;(unspecified, strong_equality v) noexcept;</pre>
</blockquote>

<p>Insert the following at the end of [cmp.strongeq] Class <code>strong_equality</code> section.</p>
<blockquote class="stdins">
  <pre>constexpr strong_equality operator&lt;=&gt;(strong_equality v, unspecified) noexcept;
constexpr strong_equality operator&lt;=&gt;(unspecified, strong_equality v) noexcept;</pre>
  
  <dl class="attribute">
    <dt>Returns:</dt>
    <dd><code>v</code></dd>
  </dl>
</blockquote>

<p>Add the following declarations at the end of the definition of the class <code></code> in [cmp.partialord] Class <code>partial_ordering</code> section.</p>
<blockquote class="stdins"> 
<pre>friend constexpr partial_ordering operator&lt;=&gt;(partial_ordering v, unspecified) noexcept;
friend constexpr partial_ordering operator&lt;=&gt;(unspecified, partial_ordering v) noexcept;</pre>
</blockquote>

<p>Insert the following at the end of [cmp.partialord] Class <code>partial_ordering</code> section.</p>
<blockquote class="stdins">
  <pre>constexpr partial_ordering operator&lt;=&gt;(partial_ordering v, unspecified) noexcept;</pre>
  
  <dl class="attribute">
    <dt>Returns:</dt>
    <dd><code>v</code></dd>
  </dl>

<pre>constexpr partial_ordering operator&lt;=&gt;(unspecified, partial_ordering v) noexcept;</pre>

  <dl class="attribute">
    <dt>Returns:</dt>
    <dd><code>v &lt; 0 ? partial_ordering::greater : v &gt; 0 ? partial_ordering::less : v</code></dd>
  </dl>
</blockquote>

<p>Add the following declarations at the end of the definition of the class <code></code> in [cmp.weakord] Class <code>weak_ordering</code> section.</p>
<blockquote class="stdins"> 
<pre>friend constexpr weak_ordering operator&lt;=&gt;(weak_ordering v, unspecified) noexcept;
friend constexpr weak_ordering operator&lt;=&gt;(unspecified, weak_ordering v) noexcept;</pre>
</blockquote>

<p>Insert the following at the end of [cmp.weakord] Class <code>weak_ordering</code> section.</p>
<blockquote class="stdins">
  <pre>constexpr weak_ordering operator&lt;=&gt;(weak_ordering v, unspecified) noexcept;</pre>
  
  <dl class="attribute">
    <dt>Returns:</dt>
    <dd><code>v</code></dd>
  </dl>

<pre>constexpr weak_ordering operator&lt;=&gt;(unspecified, weak_ordering v) noexcept;</pre>

  <dl class="attribute">
    <dt>Returns:</dt>
    <dd><code>v &lt; 0 ? weak_ordering::greater : v &gt; 0 ? weak_ordering::less : v</code></dd>
  </dl>
</blockquote>

<p>Add the following declarations at the end of the definition of the class <code></code> in [cmp.strongord] Class <code>strong_ordering</code> section.</p>
<blockquote class="stdins"> 
<pre>friend constexpr strong_ordering operator&lt;=&gt;(strong_ordering v, unspecified) noexcept;
friend constexpr strong_ordering operator&lt;=&gt;(unspecified, strong_ordering v) noexcept;</pre>
</blockquote>

<p>Insert the following at the end of [cmp.strongord] Class <code>strong_ordering</code> section.</p>
<blockquote class="stdins">
  <pre>constexpr strong_ordering operator&lt;=&gt;(strong_ordering v, unspecified) noexcept;</pre>
  
  <dl class="attribute">
    <dt>Returns:</dt>
    <dd><code>v</code></dd>
  </dl>

<pre>constexpr strong_ordering operator&lt;=&gt;(unspecified, strong_ordering v) noexcept;</pre>

  <dl class="attribute">
    <dt>Returns:</dt>
    <dd><code>v &lt; 0 ? strong_ordering::greater : v &gt; 0 ? strong_ordering::less : v</code></dd>
  </dl>
</blockquote>


<h2><a name="feature-testing">6. Feature-testing recommendation</a></h2>

<p>For the purposes of SG10, we recommend increasing the value of the macro attached to consistent comparisons (if any) to match 
   date of acceptance of this proposal.</p>

<h2><a name="implementability">7. Implementability</a></h2>

<p>At the <a href="https://raw.githubusercontent.com/tomaszkam/proposals/master/implentation/space.cpp"/>following link</a>,
   an example implementation of the comparison category types may be found - its goal is to reduce amount of branches:
   <ul>
     <li>conversions between type categories are implemented by passing unmodified integer values,</li>
     <li>inversions for ordering types are implemented as negation of underlining integer value,</li>
     <li>with the single exception of <code>&lt;=</code> and <code>&gt;=</code> for <code>partial_ordering</code>,
         comparison between comparison category and <code>0</code> are implemented using single integer
         comparison,</li>
     <li><code>&lt;=</code> and <code>&gt;=</code> for <code>partial_ordering</code> are implemented
         as disjunction of <code>&lt;</code> and <code>==</code>.
   </ul>
   This code can be tested online <a href="https://wandbox.org/permlink/OiTBleYXZfMVXyeJ">here</a> &mdash; 
   due lack of the language support, the declarations and uses of <code>operator&lt;=&gt;</code> are replaced
   with <code>operator_cmp</code> function.</p> 


<h2><a name="acknowledgements">8. Acknowledgements</a></h2>

<!--p>Jens Maurer and Andrzej Krzemieński offered many useful suggestions and corrections to the proposal.</p-->

<h2><a name="literature">9. References</a></h2>

<ol>
  <li>Eric Niebler,
      "Range Comprehensions" 
      (<a href="http://ericniebler.com/2014/04/27/range-comprehensions/">http://ericniebler.com/2014/04/27/range-comprehensions/</a>)</li>

  <li>Alexander Stepanov, Paul McJones,
      "Elements of Programming",
       Addison-Wesley Professional; 1 edition (2009)<li>
 
</ol>


</body></html>
